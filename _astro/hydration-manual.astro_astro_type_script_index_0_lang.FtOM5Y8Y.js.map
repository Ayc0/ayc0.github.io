{"version":3,"file":"hydration-manual.astro_astro_type_script_index_0_lang.FtOM5Y8Y.js","sources":["../../node_modules/.pnpm/diff@8.0.2/node_modules/diff/libesm/diff/base.js","../../node_modules/.pnpm/diff@8.0.2/node_modules/diff/libesm/diff/character.js","../../src/components/experiments/page-react-extension/hydration/manual.tsx"],"sourcesContent":["export default class Diff {\n    diff(oldStr, newStr, \n    // Type below is not accurate/complete - see above for full possibilities - but it compiles\n    options = {}) {\n        let callback;\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        else if ('callback' in options) {\n            callback = options.callback;\n        }\n        // Allow subclasses to massage the input prior to running\n        const oldString = this.castInput(oldStr, options);\n        const newString = this.castInput(newStr, options);\n        const oldTokens = this.removeEmpty(this.tokenize(oldString, options));\n        const newTokens = this.removeEmpty(this.tokenize(newString, options));\n        return this.diffWithOptionsObj(oldTokens, newTokens, options, callback);\n    }\n    diffWithOptionsObj(oldTokens, newTokens, options, callback) {\n        var _a;\n        const done = (value) => {\n            value = this.postProcess(value, options);\n            if (callback) {\n                setTimeout(function () { callback(value); }, 0);\n                return undefined;\n            }\n            else {\n                return value;\n            }\n        };\n        const newLen = newTokens.length, oldLen = oldTokens.length;\n        let editLength = 1;\n        let maxEditLength = newLen + oldLen;\n        if (options.maxEditLength != null) {\n            maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n        }\n        const maxExecutionTime = (_a = options.timeout) !== null && _a !== void 0 ? _a : Infinity;\n        const abortAfterTimestamp = Date.now() + maxExecutionTime;\n        const bestPath = [{ oldPos: -1, lastComponent: undefined }];\n        // Seed editLength = 0, i.e. the content starts with the same values\n        let newPos = this.extractCommon(bestPath[0], newTokens, oldTokens, 0, options);\n        if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n            // Identity per the equality and tokenizer\n            return done(this.buildValues(bestPath[0].lastComponent, newTokens, oldTokens));\n        }\n        // Once we hit the right edge of the edit graph on some diagonal k, we can\n        // definitely reach the end of the edit graph in no more than k edits, so\n        // there's no point in considering any moves to diagonal k+1 any more (from\n        // which we're guaranteed to need at least k+1 more edits).\n        // Similarly, once we've reached the bottom of the edit graph, there's no\n        // point considering moves to lower diagonals.\n        // We record this fact by setting minDiagonalToConsider and\n        // maxDiagonalToConsider to some finite value once we've hit the edge of\n        // the edit graph.\n        // This optimization is not faithful to the original algorithm presented in\n        // Myers's paper, which instead pointlessly extends D-paths off the end of\n        // the edit graph - see page 7 of Myers's paper which notes this point\n        // explicitly and illustrates it with a diagram. This has major performance\n        // implications for some common scenarios. For instance, to compute a diff\n        // where the new text simply appends d characters on the end of the\n        // original text of length n, the true Myers algorithm will take O(n+d^2)\n        // time while this optimization needs only O(n+d) time.\n        let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;\n        // Main worker method. checks all permutations of a given edit length for acceptance.\n        const execEditLength = () => {\n            for (let diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n                let basePath;\n                const removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];\n                if (removePath) {\n                    // No one else is going to attempt to use this value, clear it\n                    // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n                    bestPath[diagonalPath - 1] = undefined;\n                }\n                let canAdd = false;\n                if (addPath) {\n                    // what newPos will be after we do an insertion:\n                    const addPathNewPos = addPath.oldPos - diagonalPath;\n                    canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n                }\n                const canRemove = removePath && removePath.oldPos + 1 < oldLen;\n                if (!canAdd && !canRemove) {\n                    // If this path is a terminal then prune\n                    // @ts-expect-error - perf optimisation. This type-violating value will never be read.\n                    bestPath[diagonalPath] = undefined;\n                    continue;\n                }\n                // Select the diagonal that we want to branch from. We select the prior\n                // path whose position in the old string is the farthest from the origin\n                // and does not pass the bounds of the diff graph\n                if (!canRemove || (canAdd && removePath.oldPos < addPath.oldPos)) {\n                    basePath = this.addToPath(addPath, true, false, 0, options);\n                }\n                else {\n                    basePath = this.addToPath(removePath, false, true, 1, options);\n                }\n                newPos = this.extractCommon(basePath, newTokens, oldTokens, diagonalPath, options);\n                if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n                    // If we have hit the end of both strings, then we are done\n                    return done(this.buildValues(basePath.lastComponent, newTokens, oldTokens)) || true;\n                }\n                else {\n                    bestPath[diagonalPath] = basePath;\n                    if (basePath.oldPos + 1 >= oldLen) {\n                        maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n                    }\n                    if (newPos + 1 >= newLen) {\n                        minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n                    }\n                }\n            }\n            editLength++;\n        };\n        // Performs the length of edit iteration. Is a bit fugly as this has to support the\n        // sync and async mode which is never fun. Loops over execEditLength until a value\n        // is produced, or until the edit length exceeds options.maxEditLength (if given),\n        // in which case it will return undefined.\n        if (callback) {\n            (function exec() {\n                setTimeout(function () {\n                    if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n                        return callback(undefined);\n                    }\n                    if (!execEditLength()) {\n                        exec();\n                    }\n                }, 0);\n            }());\n        }\n        else {\n            while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n                const ret = execEditLength();\n                if (ret) {\n                    return ret;\n                }\n            }\n        }\n    }\n    addToPath(path, added, removed, oldPosInc, options) {\n        const last = path.lastComponent;\n        if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: { count: last.count + 1, added: added, removed: removed, previousComponent: last.previousComponent }\n            };\n        }\n        else {\n            return {\n                oldPos: path.oldPos + oldPosInc,\n                lastComponent: { count: 1, added: added, removed: removed, previousComponent: last }\n            };\n        }\n    }\n    extractCommon(basePath, newTokens, oldTokens, diagonalPath, options) {\n        const newLen = newTokens.length, oldLen = oldTokens.length;\n        let oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;\n        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldTokens[oldPos + 1], newTokens[newPos + 1], options)) {\n            newPos++;\n            oldPos++;\n            commonCount++;\n            if (options.oneChangePerToken) {\n                basePath.lastComponent = { count: 1, previousComponent: basePath.lastComponent, added: false, removed: false };\n            }\n        }\n        if (commonCount && !options.oneChangePerToken) {\n            basePath.lastComponent = { count: commonCount, previousComponent: basePath.lastComponent, added: false, removed: false };\n        }\n        basePath.oldPos = oldPos;\n        return newPos;\n    }\n    equals(left, right, options) {\n        if (options.comparator) {\n            return options.comparator(left, right);\n        }\n        else {\n            return left === right\n                || (!!options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n        }\n    }\n    removeEmpty(array) {\n        const ret = [];\n        for (let i = 0; i < array.length; i++) {\n            if (array[i]) {\n                ret.push(array[i]);\n            }\n        }\n        return ret;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    castInput(value, options) {\n        return value;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    tokenize(value, options) {\n        return Array.from(value);\n    }\n    join(chars) {\n        // Assumes ValueT is string, which is the case for most subclasses.\n        // When it's false, e.g. in diffArrays, this method needs to be overridden (e.g. with a no-op)\n        // Yes, the casts are verbose and ugly, because this pattern - of having the base class SORT OF\n        // assume tokens and values are strings, but not completely - is weird and janky.\n        return chars.join('');\n    }\n    postProcess(changeObjects, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    options) {\n        return changeObjects;\n    }\n    get useLongestToken() {\n        return false;\n    }\n    buildValues(lastComponent, newTokens, oldTokens) {\n        // First we convert our linked list of components in reverse order to an\n        // array in the right order:\n        const components = [];\n        let nextComponent;\n        while (lastComponent) {\n            components.push(lastComponent);\n            nextComponent = lastComponent.previousComponent;\n            delete lastComponent.previousComponent;\n            lastComponent = nextComponent;\n        }\n        components.reverse();\n        const componentLen = components.length;\n        let componentPos = 0, newPos = 0, oldPos = 0;\n        for (; componentPos < componentLen; componentPos++) {\n            const component = components[componentPos];\n            if (!component.removed) {\n                if (!component.added && this.useLongestToken) {\n                    let value = newTokens.slice(newPos, newPos + component.count);\n                    value = value.map(function (value, i) {\n                        const oldValue = oldTokens[oldPos + i];\n                        return oldValue.length > value.length ? oldValue : value;\n                    });\n                    component.value = this.join(value);\n                }\n                else {\n                    component.value = this.join(newTokens.slice(newPos, newPos + component.count));\n                }\n                newPos += component.count;\n                // Common case\n                if (!component.added) {\n                    oldPos += component.count;\n                }\n            }\n            else {\n                component.value = this.join(oldTokens.slice(oldPos, oldPos + component.count));\n                oldPos += component.count;\n            }\n        }\n        return components;\n    }\n}\n","import Diff from './base.js';\nclass CharacterDiff extends Diff {\n}\nexport const characterDiff = new CharacterDiff();\nexport function diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n}\n","import * as React from \"react\";\nimport { hydrateRoot } from \"react-dom/client\";\nimport * as Diff from \"diff\";\n\nconst wrapper = document.getElementById(\"root\")!;\n\nconst before = wrapper.innerHTML;\nhydrateRoot(wrapper, <div>World</div>, {\n  onRecoverableError: (error) => {\n    console.warn(\"[CUSTOM] Recoverable error\", error);\n    const after = wrapper.innerHTML;\n\n    console.log({\n      before,\n      after,\n      diff: Diff.diffChars(before, after),\n    });\n  },\n});\n"],"names":["Diff","oldStr","newStr","options","callback","oldString","newString","oldTokens","newTokens","_a","done","value","newLen","oldLen","editLength","maxEditLength","maxExecutionTime","abortAfterTimestamp","bestPath","newPos","minDiagonalToConsider","maxDiagonalToConsider","execEditLength","diagonalPath","basePath","removePath","addPath","canAdd","addPathNewPos","canRemove","exec","ret","path","added","removed","oldPosInc","last","oldPos","commonCount","left","right","array","i","chars","changeObjects","lastComponent","components","nextComponent","componentLen","componentPos","component","oldValue","CharacterDiff","characterDiff","diffChars","wrapper","before","hydrateRoot","jsx","error","after","Diff.diffChars"],"mappings":"+IAAe,MAAMA,CAAK,CACtB,KAAKC,EAAQC,EAEbC,EAAU,CAAA,EAAI,CACV,IAAIC,EACA,OAAOD,GAAY,YACnBC,EAAWD,EACXA,EAAU,CAAA,GAEL,aAAcA,IACnBC,EAAWD,EAAQ,UAGvB,MAAME,EAAY,KAAK,UAAUJ,EAAQE,CAAO,EAC1CG,EAAY,KAAK,UAAUJ,EAAQC,CAAO,EAC1CI,EAAY,KAAK,YAAY,KAAK,SAASF,EAAWF,CAAO,CAAC,EAC9DK,EAAY,KAAK,YAAY,KAAK,SAASF,EAAWH,CAAO,CAAC,EACpE,OAAO,KAAK,mBAAmBI,EAAWC,EAAWL,EAASC,CAAQ,CAC1E,CACA,mBAAmBG,EAAWC,EAAWL,EAASC,EAAU,CACxD,IAAIK,EACJ,MAAMC,EAAQC,GAAU,CAEpB,GADAA,EAAQ,KAAK,YAAYA,EAAOR,CAAO,EACnCC,EAAU,CACV,WAAW,UAAY,CAAEA,EAASO,CAAK,CAAG,EAAG,CAAC,EAC9C,MACJ,KAEI,QAAOA,CAEf,EACMC,EAASJ,EAAU,OAAQK,EAASN,EAAU,OACpD,IAAIO,EAAa,EACbC,EAAgBH,EAASC,EACzBV,EAAQ,eAAiB,OACzBY,EAAgB,KAAK,IAAIA,EAAeZ,EAAQ,aAAa,GAEjE,MAAMa,GAAoBP,EAAKN,EAAQ,WAAa,MAAQM,IAAO,OAASA,EAAK,IAC3EQ,EAAsB,KAAK,IAAG,EAAKD,EACnCE,EAAW,CAAC,CAAE,OAAQ,GAAI,cAAe,OAAW,EAE1D,IAAIC,EAAS,KAAK,cAAcD,EAAS,CAAC,EAAGV,EAAWD,EAAW,EAAGJ,CAAO,EAC7E,GAAIe,EAAS,CAAC,EAAE,OAAS,GAAKL,GAAUM,EAAS,GAAKP,EAElD,OAAOF,EAAK,KAAK,YAAYQ,EAAS,CAAC,EAAE,cAAeV,EAAWD,CAAS,CAAC,EAmBjF,IAAIa,EAAwB,KAAWC,EAAwB,IAE/D,MAAMC,EAAiB,IAAM,CACzB,QAASC,EAAe,KAAK,IAAIH,EAAuB,CAACN,CAAU,EAAGS,GAAgB,KAAK,IAAIF,EAAuBP,CAAU,EAAGS,GAAgB,EAAG,CAClJ,IAAIC,EACJ,MAAMC,EAAaP,EAASK,EAAe,CAAC,EAAGG,EAAUR,EAASK,EAAe,CAAC,EAC9EE,IAGAP,EAASK,EAAe,CAAC,EAAI,QAEjC,IAAII,EAAS,GACb,GAAID,EAAS,CAET,MAAME,EAAgBF,EAAQ,OAASH,EACvCI,EAASD,GAAW,GAAKE,GAAiBA,EAAgBhB,CAC9D,CACA,MAAMiB,EAAYJ,GAAcA,EAAW,OAAS,EAAIZ,EACxD,GAAI,CAACc,GAAU,CAACE,EAAW,CAGvBX,EAASK,CAAY,EAAI,OACzB,QACJ,CAWA,GAPI,CAACM,GAAcF,GAAUF,EAAW,OAASC,EAAQ,OACrDF,EAAW,KAAK,UAAUE,EAAS,GAAM,GAAO,EAAGvB,CAAO,EAG1DqB,EAAW,KAAK,UAAUC,EAAY,GAAO,GAAM,EAAGtB,CAAO,EAEjEgB,EAAS,KAAK,cAAcK,EAAUhB,EAAWD,EAAWgB,EAAcpB,CAAO,EAC7EqB,EAAS,OAAS,GAAKX,GAAUM,EAAS,GAAKP,EAE/C,OAAOF,EAAK,KAAK,YAAYc,EAAS,cAAehB,EAAWD,CAAS,CAAC,GAAK,GAG/EW,EAASK,CAAY,EAAIC,EACrBA,EAAS,OAAS,GAAKX,IACvBQ,EAAwB,KAAK,IAAIA,EAAuBE,EAAe,CAAC,GAExEJ,EAAS,GAAKP,IACdQ,EAAwB,KAAK,IAAIA,EAAuBG,EAAe,CAAC,EAGpF,CACAT,GACJ,EAKA,GAAIV,GACC,SAAS0B,GAAO,CACb,WAAW,UAAY,CACnB,GAAIhB,EAAaC,GAAiB,KAAK,IAAG,EAAKE,EAC3C,OAAOb,EAAS,MAAS,EAExBkB,EAAc,GACfQ,EAAI,CAEZ,EAAG,CAAC,CACR,GAAC,MAGD,MAAOhB,GAAcC,GAAiB,KAAK,IAAG,GAAME,GAAqB,CACrE,MAAMc,EAAMT,EAAc,EAC1B,GAAIS,EACA,OAAOA,CAEf,CAER,CACA,UAAUC,EAAMC,EAAOC,EAASC,EAAWhC,EAAS,CAChD,MAAMiC,EAAOJ,EAAK,cAClB,OAAII,GAAQ,CAACjC,EAAQ,mBAAqBiC,EAAK,QAAUH,GAASG,EAAK,UAAYF,EACxE,CACH,OAAQF,EAAK,OAASG,EACtB,cAAe,CAAE,MAAOC,EAAK,MAAQ,EAAG,MAAOH,EAAO,QAASC,EAAS,kBAAmBE,EAAK,iBAAiB,CACjI,EAGmB,CACH,OAAQJ,EAAK,OAASG,EACtB,cAAe,CAAE,MAAO,EAAG,MAAOF,EAAO,QAASC,EAAS,kBAAmBE,CAAI,CAClG,CAEI,CACA,cAAcZ,EAAUhB,EAAWD,EAAWgB,EAAcpB,EAAS,CACjE,MAAMS,EAASJ,EAAU,OAAQK,EAASN,EAAU,OACpD,IAAI8B,EAASb,EAAS,OAAQL,EAASkB,EAASd,EAAce,EAAc,EAC5E,KAAOnB,EAAS,EAAIP,GAAUyB,EAAS,EAAIxB,GAAU,KAAK,OAAON,EAAU8B,EAAS,CAAC,EAAG7B,EAAUW,EAAS,CAAC,EAAGhB,CAAO,GAClHgB,IACAkB,IACAC,IACInC,EAAQ,oBACRqB,EAAS,cAAgB,CAAE,MAAO,EAAG,kBAAmBA,EAAS,cAAe,MAAO,GAAO,QAAS,EAAK,GAGpH,OAAIc,GAAe,CAACnC,EAAQ,oBACxBqB,EAAS,cAAgB,CAAE,MAAOc,EAAa,kBAAmBd,EAAS,cAAe,MAAO,GAAO,QAAS,EAAK,GAE1HA,EAAS,OAASa,EACXlB,CACX,CACA,OAAOoB,EAAMC,EAAOrC,EAAS,CACzB,OAAIA,EAAQ,WACDA,EAAQ,WAAWoC,EAAMC,CAAK,EAG9BD,IAASC,GACR,CAAC,CAACrC,EAAQ,YAAcoC,EAAK,gBAAkBC,EAAM,aAErE,CACA,YAAYC,EAAO,CACf,MAAMV,EAAM,CAAA,EACZ,QAASW,EAAI,EAAGA,EAAID,EAAM,OAAQC,IAC1BD,EAAMC,CAAC,GACPX,EAAI,KAAKU,EAAMC,CAAC,CAAC,EAGzB,OAAOX,CACX,CAEA,UAAUpB,EAAOR,EAAS,CACtB,OAAOQ,CACX,CAEA,SAASA,EAAOR,EAAS,CACrB,OAAO,MAAM,KAAKQ,CAAK,CAC3B,CACA,KAAKgC,EAAO,CAKR,OAAOA,EAAM,KAAK,EAAE,CACxB,CACA,YAAYC,EAEZzC,EAAS,CACL,OAAOyC,CACX,CACA,IAAI,iBAAkB,CAClB,MAAO,EACX,CACA,YAAYC,EAAerC,EAAWD,EAAW,CAG7C,MAAMuC,EAAa,CAAA,EACnB,IAAIC,EACJ,KAAOF,GACHC,EAAW,KAAKD,CAAa,EAC7BE,EAAgBF,EAAc,kBAC9B,OAAOA,EAAc,kBACrBA,EAAgBE,EAEpBD,EAAW,QAAO,EAClB,MAAME,EAAeF,EAAW,OAChC,IAAIG,EAAe,EAAG9B,EAAS,EAAGkB,EAAS,EAC3C,KAAOY,EAAeD,EAAcC,IAAgB,CAChD,MAAMC,EAAYJ,EAAWG,CAAY,EACzC,GAAKC,EAAU,QAmBXA,EAAU,MAAQ,KAAK,KAAK3C,EAAU,MAAM8B,EAAQA,EAASa,EAAU,KAAK,CAAC,EAC7Eb,GAAUa,EAAU,UApBA,CACpB,GAAI,CAACA,EAAU,OAAS,KAAK,gBAAiB,CAC1C,IAAIvC,EAAQH,EAAU,MAAMW,EAAQA,EAAS+B,EAAU,KAAK,EAC5DvC,EAAQA,EAAM,IAAI,SAAUA,EAAO+B,EAAG,CAClC,MAAMS,EAAW5C,EAAU8B,EAASK,CAAC,EACrC,OAAOS,EAAS,OAASxC,EAAM,OAASwC,EAAWxC,CACvD,CAAC,EACDuC,EAAU,MAAQ,KAAK,KAAKvC,CAAK,CACrC,MAEIuC,EAAU,MAAQ,KAAK,KAAK1C,EAAU,MAAMW,EAAQA,EAAS+B,EAAU,KAAK,CAAC,EAEjF/B,GAAU+B,EAAU,MAEfA,EAAU,QACXb,GAAUa,EAAU,MAE5B,CAKJ,CACA,OAAOJ,CACX,CACJ,CC3PA,MAAMM,UAAsBpD,CAAK,CACjC,CACO,MAAMqD,EAAgB,IAAID,EAC1B,SAASE,EAAUrD,EAAQC,EAAQC,EAAS,CAC/C,OAAOkD,EAAc,KAAKpD,EAAQC,EAAQC,CAAO,CACrD,CCFA,MAAMoD,EAAU,SAAS,eAAe,MAAM,EAExCC,EAASD,EAAQ,UACvBE,EAAAA,YAAYF,EAASG,EAAAA,IAAC,MAAA,CAAI,SAAA,OAAA,CAAK,EAAQ,CACrC,mBAAqBC,GAAU,CAC7B,QAAQ,KAAK,6BAA8BA,CAAK,EAChD,MAAMC,EAAQL,EAAQ,UAEtB,QAAQ,IAAI,CACV,OAAAC,EACA,MAAAI,EACA,KAAMC,EAAeL,EAAQI,CAAK,CAAA,CACnC,CACH,CACF,CAAC","x_google_ignoreList":[0,1]}