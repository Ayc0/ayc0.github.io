{"version":3,"file":"fiber.KnyU7RvX.js","sources":["../../node_modules/bippy/dist/chunk-UTLFO7LL.js","../../node_modules/bippy/dist/chunk-ELVWOSDS.js","../../src/components/experiments/page-react-extension/fiber.ts"],"sourcesContent":["/**\n * @license bippy\n *\n * Copyright (c) Aiden Bai, Million Software, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// src/rdt-hook.ts\nvar version = \"0.3.8\";\nvar BIPPY_INSTRUMENTATION_STRING = `bippy-${version}`;\nvar objectDefineProperty = Object.defineProperty;\nvar objectHasOwnProperty = Object.prototype.hasOwnProperty;\nvar NO_OP = () => {\n};\nvar checkDCE = (fn) => {\n  try {\n    const code = Function.prototype.toString.call(fn);\n    if (code.indexOf(\"^_^\") > -1) {\n      setTimeout(() => {\n        throw new Error(\n          \"React is running in production mode, but dead code elimination has not been applied. Read how to correctly configure React for production: https://reactjs.org/link/perf-use-production-build\"\n        );\n      });\n    }\n  } catch {\n  }\n};\nvar isRealReactDevtools = (rdtHook = getRDTHook()) => {\n  return \"getFiberRoots\" in rdtHook;\n};\nvar isReactRefreshOverride = false;\nvar injectFnStr = void 0;\nvar isReactRefresh = (rdtHook = getRDTHook()) => {\n  if (isReactRefreshOverride) return true;\n  if (typeof rdtHook.inject === \"function\") {\n    injectFnStr = rdtHook.inject.toString();\n  }\n  return Boolean(injectFnStr?.includes(\"(injected)\"));\n};\nvar onActiveListeners = /* @__PURE__ */ new Set();\nvar installRDTHook = (onActive) => {\n  const renderers = /* @__PURE__ */ new Map();\n  let i = 0;\n  let rdtHook = {\n    checkDCE,\n    supportsFiber: true,\n    supportsFlight: true,\n    hasUnsupportedRendererAttached: false,\n    renderers,\n    onCommitFiberRoot: NO_OP,\n    onCommitFiberUnmount: NO_OP,\n    onPostCommitFiberRoot: NO_OP,\n    inject(renderer) {\n      const nextID = ++i;\n      renderers.set(nextID, renderer);\n      if (!rdtHook._instrumentationIsActive) {\n        rdtHook._instrumentationIsActive = true;\n        onActiveListeners.forEach((listener) => listener());\n      }\n      return nextID;\n    },\n    _instrumentationSource: BIPPY_INSTRUMENTATION_STRING,\n    _instrumentationIsActive: false\n  };\n  try {\n    objectDefineProperty(globalThis, \"__REACT_DEVTOOLS_GLOBAL_HOOK__\", {\n      get() {\n        return rdtHook;\n      },\n      set(newHook) {\n        if (newHook && typeof newHook === \"object\") {\n          const ourRenderers = rdtHook.renderers;\n          rdtHook = newHook;\n          if (ourRenderers.size > 0) {\n            ourRenderers.forEach((renderer, id) => {\n              newHook.renderers.set(id, renderer);\n            });\n            patchRDTHook(onActive);\n          }\n        }\n      },\n      configurable: true,\n      enumerable: true\n    });\n    const originalWindowHasOwnProperty = window.hasOwnProperty;\n    let hasRanHack = false;\n    objectDefineProperty(window, \"hasOwnProperty\", {\n      value: function() {\n        try {\n          if (!hasRanHack && // biome-ignore lint/style/noArguments: perf\n          arguments[0] === \"__REACT_DEVTOOLS_GLOBAL_HOOK__\") {\n            globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__ = void 0;\n            hasRanHack = true;\n            return -0;\n          }\n          return originalWindowHasOwnProperty.apply(this, arguments);\n        } catch {\n          return originalWindowHasOwnProperty.apply(this, arguments);\n        }\n      },\n      configurable: true,\n      writable: true\n    });\n  } catch {\n    patchRDTHook(onActive);\n  }\n  return rdtHook;\n};\nvar patchRDTHook = (onActive) => {\n  if (onActive) {\n    onActiveListeners.add(onActive);\n  }\n  try {\n    const rdtHook = globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n    if (!rdtHook) return;\n    if (!rdtHook._instrumentationSource) {\n      rdtHook.checkDCE = checkDCE;\n      rdtHook.supportsFiber = true;\n      rdtHook.supportsFlight = true;\n      rdtHook.hasUnsupportedRendererAttached = false;\n      rdtHook._instrumentationSource = BIPPY_INSTRUMENTATION_STRING;\n      rdtHook._instrumentationIsActive = false;\n      if (rdtHook.renderers.size) {\n        rdtHook._instrumentationIsActive = true;\n        onActiveListeners.forEach((listener) => listener());\n        return;\n      }\n      const prevInject = rdtHook.inject;\n      if (isReactRefresh(rdtHook) && !isRealReactDevtools()) {\n        isReactRefreshOverride = true;\n        const nextID = rdtHook.inject({\n          // @ts-expect-error this is not actually a ReactRenderer,\n          scheduleRefresh() {\n          }\n        });\n        if (nextID) {\n          rdtHook._instrumentationIsActive = true;\n        }\n      }\n      rdtHook.inject = (renderer) => {\n        const id = prevInject(renderer);\n        rdtHook._instrumentationIsActive = true;\n        onActiveListeners.forEach((listener) => listener());\n        return id;\n      };\n    }\n    if (rdtHook.renderers.size || rdtHook._instrumentationIsActive || // depending on this to inject is unsafe, since inject could occur before and we wouldn't know\n    isReactRefresh()) {\n      onActive?.();\n    }\n  } catch {\n  }\n};\nvar hasRDTHook = () => {\n  return objectHasOwnProperty.call(\n    globalThis,\n    \"__REACT_DEVTOOLS_GLOBAL_HOOK__\"\n  );\n};\nvar getRDTHook = (onActive) => {\n  if (!hasRDTHook()) {\n    return installRDTHook(onActive);\n  }\n  patchRDTHook(onActive);\n  return globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n};\nvar isClientEnvironment = () => {\n  return Boolean(\n    typeof window !== \"undefined\" && (window.document?.createElement || window.navigator?.product === \"ReactNative\")\n  );\n};\nvar safelyInstallRDTHook = () => {\n  try {\n    if (isClientEnvironment()) {\n      getRDTHook();\n    }\n  } catch {\n  }\n};\n\n// src/install-hook-script-string.ts\nvar INSTALL_HOOK_SCRIPT_STRING = \"(()=>{try{var t=()=>{};const n=new Map;let o=0;globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__={checkDCE:t,supportsFiber:!0,supportsFlight:!0,hasUnsupportedRendererAttached:!1,renderers:n,onCommitFiberRoot:t,onCommitFiberUnmount:t,onPostCommitFiberRoot:t,inject(t){var e=++o;return n.set(e,t),globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__._instrumentationIsActive=!0,e},_instrumentationIsActive:!1,_script:!0}}catch{}})()\";\n\n// src/core.ts\nvar FunctionComponentTag = 0;\nvar ClassComponentTag = 1;\nvar HostRootTag = 3;\nvar HostComponentTag = 5;\nvar HostTextTag = 6;\nvar FragmentTag = 7;\nvar ContextConsumerTag = 9;\nvar ForwardRefTag = 11;\nvar SuspenseComponentTag = 13;\nvar MemoComponentTag = 14;\nvar SimpleMemoComponentTag = 15;\nvar DehydratedSuspenseComponentTag = 18;\nvar OffscreenComponentTag = 22;\nvar LegacyHiddenComponentTag = 23;\nvar HostHoistableTag = 26;\nvar HostSingletonTag = 27;\nvar CONCURRENT_MODE_NUMBER = 60111;\nvar ELEMENT_TYPE_SYMBOL_STRING = \"Symbol(react.element)\";\nvar TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING = \"Symbol(react.transitional.element)\";\nvar CONCURRENT_MODE_SYMBOL_STRING = \"Symbol(react.concurrent_mode)\";\nvar DEPRECATED_ASYNC_MODE_SYMBOL_STRING = \"Symbol(react.async_mode)\";\nvar PerformedWork = 1;\nvar Placement = 2;\nvar Hydrating = 4096;\nvar Update = 4;\nvar Cloned = 8;\nvar ChildDeletion = 16;\nvar ContentReset = 32;\nvar Snapshot = 1024;\nvar Visibility = 8192;\nvar MutationMask = Placement | Update | ChildDeletion | ContentReset | Hydrating | Visibility | Snapshot;\nvar isValidElement = (element) => typeof element === \"object\" && element != null && \"$$typeof\" in element && // react 18 uses Symbol.for('react.element'), react 19 uses Symbol.for('react.transitional.element')\n[\n  ELEMENT_TYPE_SYMBOL_STRING,\n  TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING\n].includes(String(element.$$typeof));\nvar isValidFiber = (fiber) => typeof fiber === \"object\" && fiber != null && \"tag\" in fiber && \"stateNode\" in fiber && \"return\" in fiber && \"child\" in fiber && \"sibling\" in fiber && \"flags\" in fiber;\nvar isHostFiber = (fiber) => {\n  switch (fiber.tag) {\n    case HostComponentTag:\n    // @ts-expect-error: it exists\n    case HostHoistableTag:\n    // @ts-expect-error: it exists\n    case HostSingletonTag:\n      return true;\n    default:\n      return typeof fiber.type === \"string\";\n  }\n};\nvar isCompositeFiber = (fiber) => {\n  switch (fiber.tag) {\n    case FunctionComponentTag:\n    case ClassComponentTag:\n    case SimpleMemoComponentTag:\n    case MemoComponentTag:\n    case ForwardRefTag:\n      return true;\n    default:\n      return false;\n  }\n};\nvar traverseContexts = (fiber, selector) => {\n  try {\n    const nextDependencies = fiber.dependencies;\n    const prevDependencies = fiber.alternate?.dependencies;\n    if (!nextDependencies || !prevDependencies) return false;\n    if (typeof nextDependencies !== \"object\" || !(\"firstContext\" in nextDependencies) || typeof prevDependencies !== \"object\" || !(\"firstContext\" in prevDependencies)) {\n      return false;\n    }\n    let nextContext = nextDependencies.firstContext;\n    let prevContext = prevDependencies.firstContext;\n    while (nextContext && typeof nextContext === \"object\" && \"memoizedValue\" in nextContext || prevContext && typeof prevContext === \"object\" && \"memoizedValue\" in prevContext) {\n      if (selector(nextContext, prevContext) === true) return true;\n      nextContext = nextContext?.next;\n      prevContext = prevContext?.next;\n    }\n  } catch {\n  }\n  return false;\n};\nvar traverseState = (fiber, selector) => {\n  try {\n    let nextState = fiber.memoizedState;\n    let prevState = fiber.alternate?.memoizedState;\n    while (nextState || prevState) {\n      if (selector(nextState, prevState) === true) return true;\n      nextState = nextState?.next;\n      prevState = prevState?.next;\n    }\n  } catch {\n  }\n  return false;\n};\nvar traverseProps = (fiber, selector) => {\n  try {\n    const nextProps = fiber.memoizedProps;\n    const prevProps = fiber.alternate?.memoizedProps || {};\n    const allKeys = /* @__PURE__ */ new Set([\n      ...Object.keys(prevProps),\n      ...Object.keys(nextProps)\n    ]);\n    for (const propName of allKeys) {\n      const prevValue = prevProps?.[propName];\n      const nextValue = nextProps?.[propName];\n      if (selector(propName, nextValue, prevValue) === true) return true;\n    }\n  } catch {\n  }\n  return false;\n};\nvar didFiberRender = (fiber) => {\n  const nextProps = fiber.memoizedProps;\n  const prevProps = fiber.alternate?.memoizedProps || {};\n  const flags = fiber.flags ?? fiber.effectTag ?? 0;\n  switch (fiber.tag) {\n    case ClassComponentTag:\n    case FunctionComponentTag:\n    case ContextConsumerTag:\n    case ForwardRefTag:\n    case MemoComponentTag:\n    case SimpleMemoComponentTag: {\n      return (flags & PerformedWork) === PerformedWork;\n    }\n    default:\n      if (!fiber.alternate) return true;\n      return prevProps !== nextProps || fiber.alternate.memoizedState !== fiber.memoizedState || fiber.alternate.ref !== fiber.ref;\n  }\n};\nvar didFiberCommit = (fiber) => {\n  return Boolean(\n    (fiber.flags & (MutationMask | Cloned)) !== 0 || (fiber.subtreeFlags & (MutationMask | Cloned)) !== 0\n  );\n};\nvar getMutatedHostFibers = (fiber) => {\n  const mutations = [];\n  const stack = [fiber];\n  while (stack.length) {\n    const node = stack.pop();\n    if (!node) continue;\n    if (isHostFiber(node) && didFiberCommit(node) && didFiberRender(node)) {\n      mutations.push(node);\n    }\n    if (node.child) stack.push(node.child);\n    if (node.sibling) stack.push(node.sibling);\n  }\n  return mutations;\n};\nvar getFiberStack = (fiber) => {\n  const stack = [];\n  let currentFiber = fiber;\n  while (currentFiber.return) {\n    stack.push(currentFiber);\n    currentFiber = currentFiber.return;\n  }\n  return stack;\n};\nvar shouldFilterFiber = (fiber) => {\n  switch (fiber.tag) {\n    case DehydratedSuspenseComponentTag:\n      return true;\n    case HostTextTag:\n    case FragmentTag:\n    case LegacyHiddenComponentTag:\n    case OffscreenComponentTag:\n      return true;\n    case HostRootTag:\n      return false;\n    default: {\n      const symbolOrNumber = typeof fiber.type === \"object\" && fiber.type !== null ? fiber.type.$$typeof : fiber.type;\n      const typeSymbol = typeof symbolOrNumber === \"symbol\" ? symbolOrNumber.toString() : symbolOrNumber;\n      switch (typeSymbol) {\n        case CONCURRENT_MODE_NUMBER:\n        case CONCURRENT_MODE_SYMBOL_STRING:\n        case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:\n          return true;\n        default:\n          return false;\n      }\n    }\n  }\n};\nvar getNearestHostFiber = (fiber, ascending = false) => {\n  let hostFiber = traverseFiber(fiber, isHostFiber, ascending);\n  if (!hostFiber) {\n    hostFiber = traverseFiber(fiber, isHostFiber, !ascending);\n  }\n  return hostFiber;\n};\nvar getNearestHostFibers = (fiber) => {\n  const hostFibers = [];\n  const stack = [];\n  if (isHostFiber(fiber)) {\n    hostFibers.push(fiber);\n  } else if (fiber.child) {\n    stack.push(fiber.child);\n  }\n  while (stack.length) {\n    const currentNode = stack.pop();\n    if (!currentNode) break;\n    if (isHostFiber(currentNode)) {\n      hostFibers.push(currentNode);\n    } else if (currentNode.child) {\n      stack.push(currentNode.child);\n    }\n    if (currentNode.sibling) {\n      stack.push(currentNode.sibling);\n    }\n  }\n  return hostFibers;\n};\nvar traverseFiber = (fiber, selector, ascending = false) => {\n  if (!fiber) return null;\n  if (selector(fiber) === true) return fiber;\n  let child = ascending ? fiber.return : fiber.child;\n  while (child) {\n    const match = traverseFiber(child, selector, ascending);\n    if (match) return match;\n    child = ascending ? null : child.sibling;\n  }\n  return null;\n};\nvar getTimings = (fiber) => {\n  const totalTime = fiber?.actualDuration ?? 0;\n  let selfTime = totalTime;\n  let child = fiber?.child ?? null;\n  while (totalTime > 0 && child != null) {\n    selfTime -= child.actualDuration ?? 0;\n    child = child.sibling;\n  }\n  return { selfTime, totalTime };\n};\nvar hasMemoCache = (fiber) => {\n  return Boolean(\n    fiber.updateQueue?.memoCache\n  );\n};\nvar getType = (type) => {\n  const currentType = type;\n  if (typeof currentType === \"function\") {\n    return currentType;\n  }\n  if (typeof currentType === \"object\" && currentType) {\n    return getType(\n      currentType.type || currentType.render\n    );\n  }\n  return null;\n};\nvar getDisplayName = (type) => {\n  const currentType = type;\n  if (typeof currentType === \"string\") {\n    return currentType;\n  }\n  if (typeof currentType !== \"function\" && !(typeof currentType === \"object\" && currentType)) {\n    return null;\n  }\n  const name = currentType.displayName || currentType.name || null;\n  if (name) return name;\n  const unwrappedType = getType(currentType);\n  if (!unwrappedType) return null;\n  return unwrappedType.displayName || unwrappedType.name || null;\n};\nvar detectReactBuildType = (renderer) => {\n  try {\n    if (typeof renderer.version === \"string\" && renderer.bundleType > 0) {\n      return \"development\";\n    }\n  } catch {\n  }\n  return \"production\";\n};\nvar isInstrumentationActive = () => {\n  const rdtHook = getRDTHook();\n  return Boolean(rdtHook._instrumentationIsActive) || isRealReactDevtools() || isReactRefresh();\n};\nvar getLatestFiber = (fiber) => {\n  const alternate = fiber.alternate;\n  if (!alternate) return fiber;\n  if (alternate.actualStartTime && fiber.actualStartTime) {\n    return alternate.actualStartTime > fiber.actualStartTime ? alternate : fiber;\n  }\n  for (const root of _fiberRoots) {\n    const latestFiber = traverseFiber(root.current, (innerFiber) => {\n      if (innerFiber === fiber) return true;\n    });\n    return latestFiber || alternate;\n  }\n  return fiber;\n};\nvar fiberId = 0;\nvar fiberIdMap = /* @__PURE__ */ new WeakMap();\nvar setFiberId = (fiber, id = fiberId++) => {\n  fiberIdMap.set(fiber, id);\n};\nvar getFiberId = (fiber) => {\n  let id = fiberIdMap.get(fiber);\n  if (!id && fiber.alternate) {\n    id = fiberIdMap.get(fiber.alternate);\n  }\n  if (!id) {\n    id = fiberId++;\n    setFiberId(fiber, id);\n  }\n  return id;\n};\nvar mountFiberRecursively = (onRender, firstChild, traverseSiblings) => {\n  let fiber = firstChild;\n  while (fiber != null) {\n    if (!fiberIdMap.has(fiber)) {\n      getFiberId(fiber);\n    }\n    const shouldIncludeInTree = !shouldFilterFiber(fiber);\n    if (shouldIncludeInTree && didFiberRender(fiber)) {\n      onRender(fiber, \"mount\");\n    }\n    if (fiber.tag === SuspenseComponentTag) {\n      const isTimedOut = fiber.memoizedState !== null;\n      if (isTimedOut) {\n        const primaryChildFragment = fiber.child;\n        const fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;\n        if (fallbackChildFragment) {\n          const fallbackChild = fallbackChildFragment.child;\n          if (fallbackChild !== null) {\n            mountFiberRecursively(onRender, fallbackChild, false);\n          }\n        }\n      } else {\n        let primaryChild = null;\n        if (fiber.child !== null) {\n          primaryChild = fiber.child.child;\n        }\n        if (primaryChild !== null) {\n          mountFiberRecursively(onRender, primaryChild, false);\n        }\n      }\n    } else if (fiber.child != null) {\n      mountFiberRecursively(onRender, fiber.child, true);\n    }\n    fiber = traverseSiblings ? fiber.sibling : null;\n  }\n};\nvar updateFiberRecursively = (onRender, nextFiber, prevFiber, parentFiber) => {\n  if (!fiberIdMap.has(nextFiber)) {\n    getFiberId(nextFiber);\n  }\n  if (!prevFiber) return;\n  if (!fiberIdMap.has(prevFiber)) {\n    getFiberId(prevFiber);\n  }\n  const isSuspense = nextFiber.tag === SuspenseComponentTag;\n  const shouldIncludeInTree = !shouldFilterFiber(nextFiber);\n  if (shouldIncludeInTree && didFiberRender(nextFiber)) {\n    onRender(nextFiber, \"update\");\n  }\n  const prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;\n  const nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null;\n  if (prevDidTimeout && nextDidTimeOut) {\n    const nextFallbackChildSet = nextFiber.child?.sibling ?? null;\n    const prevFallbackChildSet = prevFiber.child?.sibling ?? null;\n    if (nextFallbackChildSet !== null && prevFallbackChildSet !== null) {\n      updateFiberRecursively(\n        onRender,\n        nextFallbackChildSet,\n        prevFallbackChildSet);\n    }\n  } else if (prevDidTimeout && !nextDidTimeOut) {\n    const nextPrimaryChildSet = nextFiber.child;\n    if (nextPrimaryChildSet !== null) {\n      mountFiberRecursively(onRender, nextPrimaryChildSet, true);\n    }\n  } else if (!prevDidTimeout && nextDidTimeOut) {\n    unmountFiberChildrenRecursively(onRender, prevFiber);\n    const nextFallbackChildSet = nextFiber.child?.sibling ?? null;\n    if (nextFallbackChildSet !== null) {\n      mountFiberRecursively(onRender, nextFallbackChildSet, true);\n    }\n  } else if (nextFiber.child !== prevFiber.child) {\n    let nextChild = nextFiber.child;\n    while (nextChild) {\n      if (nextChild.alternate) {\n        const prevChild = nextChild.alternate;\n        updateFiberRecursively(\n          onRender,\n          nextChild,\n          prevChild);\n      } else {\n        mountFiberRecursively(onRender, nextChild, false);\n      }\n      nextChild = nextChild.sibling;\n    }\n  }\n};\nvar unmountFiber = (onRender, fiber) => {\n  const isRoot = fiber.tag === HostRootTag;\n  if (isRoot || !shouldFilterFiber(fiber)) {\n    onRender(fiber, \"unmount\");\n  }\n};\nvar unmountFiberChildrenRecursively = (onRender, fiber) => {\n  const isTimedOutSuspense = fiber.tag === SuspenseComponentTag && fiber.memoizedState !== null;\n  let child = fiber.child;\n  if (isTimedOutSuspense) {\n    const primaryChildFragment = fiber.child;\n    const fallbackChildFragment = primaryChildFragment?.sibling ?? null;\n    child = fallbackChildFragment?.child ?? null;\n  }\n  while (child !== null) {\n    if (child.return !== null) {\n      unmountFiber(onRender, child);\n      unmountFiberChildrenRecursively(onRender, child);\n    }\n    child = child.sibling;\n  }\n};\nvar commitId = 0;\nvar rootInstanceMap = /* @__PURE__ */ new WeakMap();\nvar traverseRenderedFibers = (root, onRender) => {\n  const fiber = \"current\" in root ? root.current : root;\n  let rootInstance = rootInstanceMap.get(root);\n  if (!rootInstance) {\n    rootInstance = { prevFiber: null, id: commitId++ };\n    rootInstanceMap.set(root, rootInstance);\n  }\n  const { prevFiber } = rootInstance;\n  if (!fiber) {\n    unmountFiber(onRender, fiber);\n  } else if (prevFiber !== null) {\n    const wasMounted = prevFiber && prevFiber.memoizedState != null && prevFiber.memoizedState.element != null && // A dehydrated root is not considered mounted\n    prevFiber.memoizedState.isDehydrated !== true;\n    const isMounted = fiber.memoizedState != null && fiber.memoizedState.element != null && // A dehydrated root is not considered mounted\n    fiber.memoizedState.isDehydrated !== true;\n    if (!wasMounted && isMounted) {\n      mountFiberRecursively(onRender, fiber, false);\n    } else if (wasMounted && isMounted) {\n      updateFiberRecursively(onRender, fiber, fiber.alternate);\n    } else if (wasMounted && !isMounted) {\n      unmountFiber(onRender, fiber);\n    }\n  } else {\n    mountFiberRecursively(onRender, fiber, true);\n  }\n  rootInstance.prevFiber = fiber;\n};\nvar createFiberVisitor = ({\n  onRender\n}) => {\n  return (_rendererID, root, _state) => {\n    traverseRenderedFibers(root, onRender);\n  };\n};\nvar instrument = (options) => {\n  return getRDTHook(() => {\n    const rdtHook = getRDTHook();\n    options.onActive?.();\n    rdtHook._instrumentationSource = options.name ?? BIPPY_INSTRUMENTATION_STRING;\n    const prevOnCommitFiberRoot = rdtHook.onCommitFiberRoot;\n    if (options.onCommitFiberRoot) {\n      rdtHook.onCommitFiberRoot = (rendererID, root, priority) => {\n        if (prevOnCommitFiberRoot)\n          prevOnCommitFiberRoot(rendererID, root, priority);\n        options.onCommitFiberRoot?.(rendererID, root, priority);\n      };\n    }\n    const prevOnCommitFiberUnmount = rdtHook.onCommitFiberUnmount;\n    if (options.onCommitFiberUnmount) {\n      rdtHook.onCommitFiberUnmount = (rendererID, root) => {\n        if (prevOnCommitFiberUnmount)\n          prevOnCommitFiberUnmount(rendererID, root);\n        options.onCommitFiberUnmount?.(rendererID, root);\n      };\n    }\n    const prevOnPostCommitFiberRoot = rdtHook.onPostCommitFiberRoot;\n    if (options.onPostCommitFiberRoot) {\n      rdtHook.onPostCommitFiberRoot = (rendererID, root) => {\n        if (prevOnPostCommitFiberRoot)\n          prevOnPostCommitFiberRoot(rendererID, root);\n        options.onPostCommitFiberRoot?.(rendererID, root);\n      };\n    }\n  });\n};\nvar getFiberFromHostInstance = (hostInstance) => {\n  const rdtHook = getRDTHook();\n  for (const renderer of rdtHook.renderers.values()) {\n    try {\n      const fiber = renderer.findFiberByHostInstance?.(hostInstance);\n      if (fiber) return fiber;\n    } catch {\n    }\n  }\n  if (typeof hostInstance === \"object\" && hostInstance != null) {\n    if (\"_reactRootContainer\" in hostInstance) {\n      return hostInstance._reactRootContainer?._internalRoot?.current?.child;\n    }\n    for (const key in hostInstance) {\n      if (key.startsWith(\"__reactInternalInstance$\") || key.startsWith(\"__reactFiber\")) {\n        return hostInstance[key] || null;\n      }\n    }\n  }\n  return null;\n};\nvar INSTALL_ERROR = new Error();\nvar _fiberRoots = /* @__PURE__ */ new Set();\nvar secure = (options, secureOptions = {}) => {\n  const onActive = options.onActive;\n  const isRDTHookInstalled = hasRDTHook();\n  const isUsingRealReactDevtools = isRealReactDevtools();\n  const isUsingReactRefresh = isReactRefresh();\n  let timeout;\n  let isProduction = secureOptions.isProduction ?? false;\n  options.onActive = () => {\n    clearTimeout(timeout);\n    let isSecure = true;\n    try {\n      const rdtHook = getRDTHook();\n      for (const renderer of rdtHook.renderers.values()) {\n        const [majorVersion] = renderer.version.split(\".\");\n        if (Number(majorVersion) < (secureOptions.minReactMajorVersion ?? 17)) {\n          isSecure = false;\n        }\n        const buildType = detectReactBuildType(renderer);\n        if (buildType !== \"development\") {\n          isProduction = true;\n          if (!secureOptions.dangerouslyRunInProduction) {\n            isSecure = false;\n          }\n        }\n      }\n    } catch (err) {\n      secureOptions.onError?.(err);\n    }\n    if (!isSecure) {\n      options.onCommitFiberRoot = void 0;\n      options.onCommitFiberUnmount = void 0;\n      options.onPostCommitFiberRoot = void 0;\n      options.onActive = void 0;\n      return;\n    }\n    onActive?.();\n    try {\n      const onCommitFiberRoot2 = options.onCommitFiberRoot;\n      if (onCommitFiberRoot2) {\n        options.onCommitFiberRoot = (rendererID, root, priority) => {\n          if (!_fiberRoots.has(root)) {\n            _fiberRoots.add(root);\n          }\n          try {\n            onCommitFiberRoot2(rendererID, root, priority);\n          } catch (err) {\n            secureOptions.onError?.(err);\n          }\n        };\n      }\n      const onCommitFiberUnmount = options.onCommitFiberUnmount;\n      if (onCommitFiberUnmount) {\n        options.onCommitFiberUnmount = (rendererID, root) => {\n          try {\n            onCommitFiberUnmount(rendererID, root);\n          } catch (err) {\n            secureOptions.onError?.(err);\n          }\n        };\n      }\n      const onPostCommitFiberRoot = options.onPostCommitFiberRoot;\n      if (onPostCommitFiberRoot) {\n        options.onPostCommitFiberRoot = (rendererID, root) => {\n          try {\n            onPostCommitFiberRoot(rendererID, root);\n          } catch (err) {\n            secureOptions.onError?.(err);\n          }\n        };\n      }\n    } catch (err) {\n      secureOptions.onError?.(err);\n    }\n  };\n  if (!isRDTHookInstalled && !isUsingRealReactDevtools && !isUsingReactRefresh) {\n    timeout = setTimeout(() => {\n      if (!isProduction) {\n        secureOptions.onError?.(INSTALL_ERROR);\n      }\n      stop();\n    }, secureOptions.installCheckTimeout ?? 100);\n  }\n  return options;\n};\nvar onCommitFiberRoot = (handler) => {\n  return instrument(\n    secure({\n      onCommitFiberRoot: (_, root) => {\n        handler(root);\n      }\n    })\n  );\n};\n\nexport { BIPPY_INSTRUMENTATION_STRING, CONCURRENT_MODE_NUMBER, CONCURRENT_MODE_SYMBOL_STRING, ClassComponentTag, ContextConsumerTag, DEPRECATED_ASYNC_MODE_SYMBOL_STRING, DehydratedSuspenseComponentTag, ELEMENT_TYPE_SYMBOL_STRING, ForwardRefTag, FragmentTag, FunctionComponentTag, HostComponentTag, HostHoistableTag, HostRootTag, HostSingletonTag, HostTextTag, INSTALL_ERROR, INSTALL_HOOK_SCRIPT_STRING, LegacyHiddenComponentTag, MemoComponentTag, OffscreenComponentTag, SimpleMemoComponentTag, SuspenseComponentTag, TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING, _fiberRoots, createFiberVisitor, detectReactBuildType, didFiberCommit, didFiberRender, fiberIdMap, getDisplayName, getFiberFromHostInstance, getFiberId, getFiberStack, getLatestFiber, getMutatedHostFibers, getNearestHostFiber, getNearestHostFibers, getRDTHook, getTimings, getType, hasMemoCache, hasRDTHook, installRDTHook, instrument, isClientEnvironment, isCompositeFiber, isHostFiber, isInstrumentationActive, isReactRefresh, isRealReactDevtools, isValidElement, isValidFiber, mountFiberRecursively, onCommitFiberRoot, patchRDTHook, safelyInstallRDTHook, secure, setFiberId, shouldFilterFiber, traverseContexts, traverseFiber, traverseProps, traverseRenderedFibers, traverseState, unmountFiber, unmountFiberChildrenRecursively, updateFiberRecursively, version };\n","import { safelyInstallRDTHook } from './chunk-UTLFO7LL.js';\n\n/**\n * @license bippy\n *\n * Copyright (c) Aiden Bai, Million Software, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// src/index.ts\nsafelyInstallRDTHook();\n","import { getFiberStack, getDisplayName, type Fiber } from \"bippy\";\n\nexport function getFiberName(fiber: Fiber | null) {\n  if (!fiber) {\n    return null;\n  }\n  if (typeof fiber.type === \"string\") {\n    return fiber.type;\n  }\n  return getDisplayName(fiber);\n}\n\nexport function getFiberFromElement(element: EventTarget) {\n  const keys = Object.keys(element);\n  const reactFiberKey = keys.find((key) => key.startsWith(\"__reactFiber$\"));\n  if (!reactFiberKey) {\n    return undefined;\n  }\n  // @ts-expect-error\n  const fiber = element[reactFiberKey] as Fiber;\n  return fiber;\n}\n\nexport function getRoot(fiber: Fiber) {\n  let current = fiber;\n  while (current.return) {\n    current = current.return;\n  }\n  return current.stateNode;\n}\n\nexport function getFiberData(fiber: Fiber | null) {\n  return {\n    fiberName: getFiberName(fiber),\n    fiberStack: fiber\n      ? getFiberStack(fiber)\n          .map(getFiberName)\n          .filter(Boolean)\n          .reverse()\n          .join(\" > \")\n      : null,\n  };\n}\n"],"names":["version","BIPPY_INSTRUMENTATION_STRING","objectDefineProperty","objectHasOwnProperty","NO_OP","checkDCE","fn","isRealReactDevtools","rdtHook","getRDTHook","isReactRefreshOverride","injectFnStr","isReactRefresh","onActiveListeners","installRDTHook","onActive","renderers","i","renderer","nextID","listener","newHook","ourRenderers","id","patchRDTHook","originalWindowHasOwnProperty","hasRanHack","prevInject","hasRDTHook","isClientEnvironment","safelyInstallRDTHook","getFiberStack","fiber","stack","currentFiber","getType","type","currentType","getDisplayName","name","unwrappedType","getFiberName","getFiberFromElement","element","reactFiberKey","key","getFiberData"],"mappings":"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","x_google_ignoreList":[0,1]}