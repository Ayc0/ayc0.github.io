{"version":3,"file":"_utils.C7Vwdp56.js","sources":["../../src/components/experiments/page-react-extension/stack/_utils.ts"],"sourcesContent":["import { getDisplayName } from \"bippy\";\nimport * as React from \"react\";\n\n// Copied from https://github.com/facebook/react/blob/da996a15be4f14aeb9726037f4559ff1cb3c2600/packages/shared/DefaultPrepareStackTraceV8.js\n// function DefaultPrepareStackTrace(\n//   error: Error,\n//   structuredStackTrace: any[],\n// ): string {\n//   const name = error.name || \"Error\";\n//   const message = error.message || \"\";\n//   let stack = name + \": \" + message;\n//   for (let i = 0; i < structuredStackTrace.length; i++) {\n//     stack += \"\\n    at \" + structuredStackTrace[i].toString();\n//   }\n//   return stack;\n// }\n\n// Doesn't work for debugging errors\n// But works for the React devtools & for some minified logs:\n// - CustomPragma ✅\n// - Foo ❌ (says O.render, not Foo.render)\n// - Bar ❌ (says \"\", not BarInternal nor Bar)\nexport function setName(obj: any, name: string) {\n  Object.defineProperty(obj, \"name\", {\n    writable: false,\n    enumerable: false,\n    configurable: true,\n    value: name,\n  });\n}\n\n// Inspired from https://github.com/facebook/react/blob/4a9df08157f001c01b078d259748512211233dcf/packages/shared/ReactOwnerStackFrames.js#L12 but swapped `react-stack-top-frame` with `========`\nexport function formatStack(error: Error): string {\n  // const prevPrepareStackTrace = Error.prepareStackTrace;\n  // Error.prepareStackTrace = DefaultPrepareStackTrace;\n  let stack = error.stack!;\n  // Error.prepareStackTrace = prevPrepareStackTrace;\n  if (stack.startsWith(\"Error: ========\\n\")) {\n    // V8's default formatting prefixes with the error message which we\n    // don't want/need.\n    stack = stack.slice(\"Error: ========\\n\".length);\n  }\n  let idx = stack.indexOf(\"\\n\");\n  if (idx !== -1) {\n    // Pop the h frame.\n    // For Chrome & FF\n    stack = stack.slice(idx + 1);\n  }\n\n  // Only keep 1 line:\n  idx = stack.indexOf(\"\\n\");\n  if (idx !== -1) {\n    // Pop the h frame.\n    // For Chrome & FF\n    stack = stack.slice(0, idx + 1);\n  }\n\n  // react-stack-bottom-frame only exists in __DEV__, so can't be used for prod build\n  idx = stack.indexOf(\"react-stack-bottom-frame\");\n  if (idx === 0) {\n    return \"\";\n  }\n  if (idx !== -1) {\n    idx = stack.lastIndexOf(\"\\n\", idx);\n  }\n  if (idx !== -1) {\n    // Cut off everything after the bottom frame since it'll be internals.\n    stack = stack.slice(0, idx);\n  } else {\n    // We didn't find any internal callsite out to user space.\n    // This means that this was called outside an owner or the owner is fully internal.\n    // To keep things light we exclude the entire trace in this case.\n    // Difference from copied code: I commented this out to keep the full stack\n    // return \"\";\n  }\n  return stack;\n}\n\n// Doesn't work for `<div>` aka native string element, but works for components\nconst MAPPED_TYPES = new WeakMap<any, Error>();\n\n// Doesn't work for `<A />` aka prop-less components, should work okay-ish for others\nconst MAPPED_PROPS = new WeakMap<any, Error>();\nconst conflictProps = new WeakSet<any>();\n\n// @ts-expect-error\nexport const h: typeof React.createElement = (type, ...args) => {\n  // Note: those don't work nicely:\n  // - with class in Firefox: only display `render`, not `ComponentName.render`\n  // - in Safari: only `h` appears, not the component render\n  const debugStack = new Error(\"========\");\n\n  // When converting ReactElement to Fiber, only the type & the props are passed, so we can only play with those 2\n  // See https://github.com/facebook/react/blob/da996a15be4f14aeb9726037f4559ff1cb3c2600/packages/react-reconciler/src/ReactFiber.js#L746-L756 or https://github.com/facebook/react/blob/da996a15be4f14aeb9726037f4559ff1cb3c2600/packages/react-reconciler/src/ReactFiber.js#L546\n\n  if (typeof type === \"function\") {\n    // We could want to bind to have a location per render, but realistically those don't change\n    const cloned = type;\n\n    // const cloned = type.bind();\n\n    // const name = type.displayName || type.name;\n    // setName(cloned, name);\n\n    MAPPED_TYPES.set(cloned, debugStack);\n    type = cloned;\n    // console.log(\"[CUSTOM] function\", debugStack.stack?.split(\"\\n\"));\n  } else if (type && typeof type === \"object\" && \"$$typeof\" in type) {\n    if (type.$$typeof === Symbol.for(\"react.memo\")) {\n      MAPPED_TYPES.set(type, debugStack); // Set for fiber.elementType\n      // MAPPED_TYPES.set(type.type, debugStack); // Set for fiber.type\n\n      // For Object.memo, often we use them with anonymous functions, like React.memo(() => <div />)\n      // But this generates \"\" for the name for the stack traces\n      if (\n        !type.type.name &&\n        (getDisplayName(type.type) || getDisplayName(type))\n      ) {\n        setName(\n          type.type,\n          getDisplayName(type.type) || \"memo(\" + getDisplayName(type) + \")\",\n        );\n      }\n    } else {\n      console.log(\"[CUSTOM] OTHER TYPE\", type, {\n        debugStack,\n        owner: formatStack(debugStack),\n      });\n    }\n  } else if (typeof type === \"string\") {\n    // Do nothing\n  } else {\n    console.log(\"[CUSTOM] OTHER TYPE\", type, {\n      debugStack,\n      owner: formatStack(debugStack),\n    });\n  }\n\n  // if (type && typeof type === \"object\") {\n  // TODO: handle `memo` & `forwardRef` (& `lazy`?)\n  // }\n\n  // Re-enable this comment to see the full pretty error when the React devtools are installed\n  // console.error(\"HA\");\n  // console.log(\"[CUSTOM] stack\", {\n  //   raw: debugStack.stack.split(\"\\n\"),\n  //   formatted: formatStack(debugStack),\n  // });\n\n  const element = React.createElement(type, ...args);\n  // mapType.set(element, debugStack);\n\n  if (element.props) {\n    if (MAPPED_PROPS.has(element.props)) {\n      console.warn(\n        \"[CUSTOM] THIS SHOULD NOT EXIST: CONFLICT ON \",\n        element.props,\n        element,\n      );\n      MAPPED_PROPS.delete(element.props);\n      conflictProps.add(element.props);\n    }\n    if (!conflictProps.has(element.props)) {\n      MAPPED_PROPS.set(element.props, debugStack);\n    }\n  }\n\n  return element;\n};\n\n// @ts-expect-error\nwindow._DEBUG_MAPPED_TYPES = MAPPED_TYPES;\n// @ts-expect-error\nwindow._DEBUG_MAPPED_PROPS = MAPPED_PROPS;\n"],"names":["setName","obj","name","formatStack","error","stack","idx","MAPPED_TYPES","MAPPED_PROPS","conflictProps","h","type","args","debugStack","cloned","getDisplayName","element","React.createElement"],"mappings":"yFAsBgB,SAAAA,EAAQC,EAAUC,EAAc,CACvC,OAAA,eAAeD,EAAK,OAAQ,CACjC,SAAU,GACV,WAAY,GACZ,aAAc,GACd,MAAOC,CAAA,CACR,CACH,CAGO,SAASC,EAAYC,EAAsB,CAGhD,IAAIC,EAAQD,EAAM,MAEdC,EAAM,WAAW;AAAA,CAAmB,IAG9BA,EAAAA,EAAM,MAAM,EAA0B,GAE5C,IAAAC,EAAMD,EAAM,QAAQ;AAAA,CAAI,EAiB5B,OAhBIC,IAAQ,KAGFD,EAAAA,EAAM,MAAMC,EAAM,CAAC,GAIvBA,EAAAD,EAAM,QAAQ;AAAA,CAAI,EACpBC,IAAQ,KAGVD,EAAQA,EAAM,MAAM,EAAGC,EAAM,CAAC,GAI1BA,EAAAD,EAAM,QAAQ,0BAA0B,EAC1CC,IAAQ,EACH,IAELA,IAAQ,KACJA,EAAAD,EAAM,YAAY;AAAA,EAAMC,CAAG,GAE/BA,IAAQ,KAEFD,EAAAA,EAAM,MAAM,EAAGC,CAAG,GAQrBD,EACT,CAGA,MAAME,MAAmB,QAGnBC,MAAmB,QACnBC,MAAoB,QAGbC,EAAgC,CAACC,KAASC,IAAS,CAIxD,MAAAC,EAAa,IAAI,MAAM,UAAU,EAKnC,GAAA,OAAOF,GAAS,WAAY,CAE9B,MAAMG,EAASH,EAOFJ,EAAA,IAAIO,EAAQD,CAAU,EAC5BF,EAAAG,CAAA,MAEEH,GAAQ,OAAOA,GAAS,UAAY,aAAcA,EACvDA,EAAK,WAAa,OAAO,IAAI,YAAY,GAC9BJ,EAAA,IAAII,EAAME,CAAU,EAM/B,CAACF,EAAK,KAAK,OACVI,EAAeJ,EAAK,IAAI,GAAKI,EAAeJ,CAAI,IAEjDX,EACEW,EAAK,KACLI,EAAeJ,EAAK,IAAI,GAAK,QAAUI,EAAeJ,CAAI,EAAI,GAChE,GAGM,QAAA,IAAI,sBAAuBA,EAAM,CACvC,WAAAE,EACA,MAAOV,EAAYU,CAAU,CAAA,CAC9B,EAEM,OAAOF,GAAS,UAGjB,QAAA,IAAI,sBAAuBA,EAAM,CACvC,WAAAE,EACA,MAAOV,EAAYU,CAAU,CAAA,CAC9B,EAcH,MAAMG,EAAUC,EAAAA,cAAoBN,EAAM,GAAGC,CAAI,EAGjD,OAAII,EAAQ,QACNR,EAAa,IAAIQ,EAAQ,KAAK,IACxB,QAAA,KACN,+CACAA,EAAQ,MACRA,CACF,EACaR,EAAA,OAAOQ,EAAQ,KAAK,EACnBP,EAAA,IAAIO,EAAQ,KAAK,GAE5BP,EAAc,IAAIO,EAAQ,KAAK,GACrBR,EAAA,IAAIQ,EAAQ,MAAOH,CAAU,GAIvCG,CACT,EAGA,OAAO,oBAAsBT,EAE7B,OAAO,oBAAsBC"}