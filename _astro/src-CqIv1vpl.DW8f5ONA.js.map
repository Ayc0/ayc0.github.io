{"version":3,"file":"src-CqIv1vpl.DW8f5ONA.js","sources":["../../node_modules/.pnpm/bippy@0.3.28_@types+react@19.2.2_react@19.2.0/node_modules/bippy/dist/src-CqIv1vpl.js"],"sourcesContent":["/**\n * @license bippy\n *\n * Copyright (c) Aiden Bai\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n//#region src/rdt-hook.ts\nconst version = \"0.3.28\";\nconst BIPPY_INSTRUMENTATION_STRING = `bippy-${version}`;\nconst objectDefineProperty = Object.defineProperty;\nconst objectHasOwnProperty = Object.prototype.hasOwnProperty;\nconst NO_OP = () => {};\nconst checkDCE = (fn) => {\n\ttry {\n\t\tconst code = Function.prototype.toString.call(fn);\n\t\tif (code.indexOf(\"^_^\") > -1) setTimeout(() => {\n\t\t\tthrow new Error(\"React is running in production mode, but dead code elimination has not been applied. Read how to correctly configure React for production: https://reactjs.org/link/perf-use-production-build\");\n\t\t});\n\t} catch {}\n};\nconst isRealReactDevtools = (rdtHook = getRDTHook()) => {\n\treturn \"getFiberRoots\" in rdtHook;\n};\nlet isReactRefreshOverride = false;\nlet injectFnStr = void 0;\nconst isReactRefresh = (rdtHook = getRDTHook()) => {\n\tif (isReactRefreshOverride) return true;\n\tif (typeof rdtHook.inject === \"function\") injectFnStr = rdtHook.inject.toString();\n\treturn Boolean(injectFnStr?.includes(\"(injected)\"));\n};\nconst onActiveListeners = new Set();\nconst _renderers = new Set();\nconst installRDTHook = (onActive) => {\n\tconst renderers = new Map();\n\tlet i = 0;\n\tlet rdtHook = {\n\t\tcheckDCE,\n\t\tsupportsFiber: true,\n\t\tsupportsFlight: true,\n\t\thasUnsupportedRendererAttached: false,\n\t\trenderers,\n\t\tonCommitFiberRoot: NO_OP,\n\t\tonCommitFiberUnmount: NO_OP,\n\t\tonPostCommitFiberRoot: NO_OP,\n\t\ton: NO_OP,\n\t\tinject(renderer) {\n\t\t\tconst nextID = ++i;\n\t\t\trenderers.set(nextID, renderer);\n\t\t\t_renderers.add(renderer);\n\t\t\tif (!rdtHook._instrumentationIsActive) {\n\t\t\t\trdtHook._instrumentationIsActive = true;\n\t\t\t\tonActiveListeners.forEach((listener) => listener());\n\t\t\t}\n\t\t\treturn nextID;\n\t\t},\n\t\t_instrumentationSource: BIPPY_INSTRUMENTATION_STRING,\n\t\t_instrumentationIsActive: false\n\t};\n\ttry {\n\t\tobjectDefineProperty(globalThis, \"__REACT_DEVTOOLS_GLOBAL_HOOK__\", {\n\t\t\tget() {\n\t\t\t\treturn rdtHook;\n\t\t\t},\n\t\t\tset(newHook) {\n\t\t\t\tif (newHook && typeof newHook === \"object\") {\n\t\t\t\t\tconst ourRenderers = rdtHook.renderers;\n\t\t\t\t\trdtHook = newHook;\n\t\t\t\t\tif (ourRenderers.size > 0) {\n\t\t\t\t\t\tourRenderers.forEach((renderer, id) => {\n\t\t\t\t\t\t\t_renderers.add(renderer);\n\t\t\t\t\t\t\tnewHook.renderers.set(id, renderer);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tpatchRDTHook(onActive);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true\n\t\t});\n\t\tconst originalWindowHasOwnProperty = window.hasOwnProperty;\n\t\tlet hasRanHack = false;\n\t\tobjectDefineProperty(window, \"hasOwnProperty\", {\n\t\t\tvalue: function() {\n\t\t\t\ttry {\n\t\t\t\t\tif (!hasRanHack && arguments[0] === \"__REACT_DEVTOOLS_GLOBAL_HOOK__\") {\n\t\t\t\t\t\tglobalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__ = void 0;\n\t\t\t\t\t\thasRanHack = true;\n\t\t\t\t\t\treturn -0;\n\t\t\t\t\t}\n\t\t\t\t} catch {}\n\t\t\t\treturn originalWindowHasOwnProperty.apply(this, arguments);\n\t\t\t},\n\t\t\tconfigurable: true,\n\t\t\twritable: true\n\t\t});\n\t} catch {\n\t\tpatchRDTHook(onActive);\n\t}\n\treturn rdtHook;\n};\nconst patchRDTHook = (onActive) => {\n\tif (onActive) onActiveListeners.add(onActive);\n\ttry {\n\t\tconst rdtHook = globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\t\tif (!rdtHook) return;\n\t\tif (!rdtHook._instrumentationSource) {\n\t\t\trdtHook.checkDCE = checkDCE;\n\t\t\trdtHook.supportsFiber = true;\n\t\t\trdtHook.supportsFlight = true;\n\t\t\trdtHook.hasUnsupportedRendererAttached = false;\n\t\t\trdtHook._instrumentationSource = BIPPY_INSTRUMENTATION_STRING;\n\t\t\trdtHook._instrumentationIsActive = false;\n\t\t\trdtHook.on = NO_OP;\n\t\t\tif (rdtHook.renderers.size) {\n\t\t\t\trdtHook._instrumentationIsActive = true;\n\t\t\t\tonActiveListeners.forEach((listener) => listener());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst prevInject = rdtHook.inject;\n\t\t\tif (isReactRefresh(rdtHook) && !isRealReactDevtools()) {\n\t\t\t\tisReactRefreshOverride = true;\n\t\t\t\tconst nextID = rdtHook.inject({ scheduleRefresh() {} });\n\t\t\t\tif (nextID) rdtHook._instrumentationIsActive = true;\n\t\t\t}\n\t\t\trdtHook.inject = (renderer) => {\n\t\t\t\tconst id = prevInject(renderer);\n\t\t\t\t_renderers.add(renderer);\n\t\t\t\trdtHook._instrumentationIsActive = true;\n\t\t\t\tonActiveListeners.forEach((listener) => listener());\n\t\t\t\treturn id;\n\t\t\t};\n\t\t}\n\t\tif (rdtHook.renderers.size || rdtHook._instrumentationIsActive || isReactRefresh()) onActive?.();\n\t} catch {}\n};\nconst hasRDTHook = () => {\n\treturn objectHasOwnProperty.call(globalThis, \"__REACT_DEVTOOLS_GLOBAL_HOOK__\");\n};\n/**\n* Returns the current React DevTools global hook.\n*/\nconst getRDTHook = (onActive) => {\n\tif (!hasRDTHook()) return installRDTHook(onActive);\n\tpatchRDTHook(onActive);\n\treturn globalThis.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n};\nconst isClientEnvironment = () => {\n\treturn Boolean(typeof window !== \"undefined\" && (window.document?.createElement || window.navigator?.product === \"ReactNative\"));\n};\n/**\n* Usually used purely for side effect\n*/\nconst safelyInstallRDTHook = () => {\n\ttry {\n\t\tif (isClientEnvironment()) getRDTHook();\n\t} catch {}\n};\n\n//#endregion\n//#region src/core.ts\nconst FunctionComponentTag = 0;\nconst ClassComponentTag = 1;\nconst HostRootTag = 3;\nconst HostComponentTag = 5;\nconst HostTextTag = 6;\nconst FragmentTag = 7;\nconst ContextConsumerTag = 9;\nconst ForwardRefTag = 11;\nconst SuspenseComponentTag = 13;\nconst MemoComponentTag = 14;\nconst SimpleMemoComponentTag = 15;\nconst LazyComponentTag = 16;\nconst DehydratedSuspenseComponentTag = 18;\nconst SuspenseListComponentTag = 19;\nconst OffscreenComponentTag = 22;\nconst LegacyHiddenComponentTag = 23;\nconst HostHoistableTag = 26;\nconst HostSingletonTag = 27;\nconst ActivityComponentTag = 28;\nconst ViewTransitionComponentTag = 30;\nconst CONCURRENT_MODE_NUMBER = 60111;\nconst ELEMENT_TYPE_SYMBOL_STRING = \"Symbol(react.element)\";\nconst TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING = \"Symbol(react.transitional.element)\";\nconst CONCURRENT_MODE_SYMBOL_STRING = \"Symbol(react.concurrent_mode)\";\nconst DEPRECATED_ASYNC_MODE_SYMBOL_STRING = \"Symbol(react.async_mode)\";\nconst PerformedWork = 1;\nconst Placement = 2;\nconst Hydrating = 4096;\nconst Update = 4;\nconst Cloned = 8;\nconst ChildDeletion = 16;\nconst ContentReset = 32;\nconst Snapshot = 1024;\nconst Visibility = 8192;\nconst MutationMask = Placement | Update | ChildDeletion | ContentReset | Hydrating | Visibility | Snapshot;\n/**\n* Returns `true` if object is a React Element.\n*\n* @see https://react.dev/reference/react/isValidElement\n*/\nconst isValidElement = (element) => typeof element === \"object\" && element != null && \"$$typeof\" in element && [ELEMENT_TYPE_SYMBOL_STRING, TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING].includes(String(element.$$typeof));\n/**\n* Returns `true` if object is a React Fiber.\n*/\nconst isValidFiber = (fiber) => typeof fiber === \"object\" && fiber != null && \"tag\" in fiber && \"stateNode\" in fiber && \"return\" in fiber && \"child\" in fiber && \"sibling\" in fiber && \"flags\" in fiber;\n/**\n* Returns `true` if fiber is a host fiber. Host fibers are DOM nodes in react-dom, `View` in react-native, etc.\n*\n* @see https://reactnative.dev/architecture/glossary#host-view-tree-and-host-view\n*/\nconst isHostFiber = (fiber) => {\n\tswitch (fiber.tag) {\n\t\tcase HostComponentTag:\n\t\tcase HostHoistableTag:\n\t\tcase HostSingletonTag: return true;\n\t\tdefault: return typeof fiber.type === \"string\";\n\t}\n};\n/**\n* Returns `true` if fiber is a composite fiber. Composite fibers are fibers that can render (like functional components, class components, etc.)\n*\n* @see https://reactnative.dev/architecture/glossary#react-composite-components\n*/\nconst isCompositeFiber = (fiber) => {\n\tswitch (fiber.tag) {\n\t\tcase FunctionComponentTag:\n\t\tcase ClassComponentTag:\n\t\tcase SimpleMemoComponentTag:\n\t\tcase MemoComponentTag:\n\t\tcase ForwardRefTag: return true;\n\t\tdefault: return false;\n\t}\n};\n/**\n* Returns `true` if the two {@link Fiber}s are the same reference\n*/\nconst areFiberEqual = (fiberA, fiberB) => {\n\treturn fiberA === fiberB || fiberA.alternate === fiberB || fiberB.alternate === fiberA;\n};\n/**\n* Traverses up or down a {@link Fiber}'s contexts, return `true` to stop and select the current and previous context value.\n*/\nconst traverseContexts = (fiber, selector) => {\n\ttry {\n\t\tconst nextDependencies = fiber.dependencies;\n\t\tconst prevDependencies = fiber.alternate?.dependencies;\n\t\tif (!nextDependencies || !prevDependencies) return false;\n\t\tif (typeof nextDependencies !== \"object\" || !(\"firstContext\" in nextDependencies) || typeof prevDependencies !== \"object\" || !(\"firstContext\" in prevDependencies)) return false;\n\t\tlet nextContext = nextDependencies.firstContext;\n\t\tlet prevContext = prevDependencies.firstContext;\n\t\twhile (nextContext && typeof nextContext === \"object\" && \"memoizedValue\" in nextContext || prevContext && typeof prevContext === \"object\" && \"memoizedValue\" in prevContext) {\n\t\t\tif (selector(nextContext, prevContext) === true) return true;\n\t\t\tnextContext = nextContext?.next;\n\t\t\tprevContext = prevContext?.next;\n\t\t}\n\t} catch {}\n\treturn false;\n};\n/**\n* Traverses up or down a {@link Fiber}'s states, return `true` to stop and select the current and previous state value. This stores both state values and effects.\n*/\nconst traverseState = (fiber, selector) => {\n\ttry {\n\t\tlet nextState = fiber.memoizedState;\n\t\tlet prevState = fiber.alternate?.memoizedState;\n\t\twhile (nextState || prevState) {\n\t\t\tif (selector(nextState, prevState) === true) return true;\n\t\t\tnextState = nextState?.next;\n\t\t\tprevState = prevState?.next;\n\t\t}\n\t} catch {}\n\treturn false;\n};\n/**\n* Traverses up or down a {@link Fiber}'s props, return `true` to stop and select the current and previous props value.\n*/\nconst traverseProps = (fiber, selector) => {\n\ttry {\n\t\tconst nextProps = fiber.memoizedProps;\n\t\tconst prevProps = fiber.alternate?.memoizedProps || {};\n\t\tconst allKeys = new Set([...Object.keys(prevProps), ...Object.keys(nextProps)]);\n\t\tfor (const propName of allKeys) {\n\t\t\tconst prevValue = prevProps?.[propName];\n\t\t\tconst nextValue = nextProps?.[propName];\n\t\t\tif (selector(propName, nextValue, prevValue) === true) return true;\n\t\t}\n\t} catch {}\n\treturn false;\n};\n/**\n* Returns `true` if the {@link Fiber} has rendered. Note that this does not mean the fiber has rendered in the current commit, just that it has rendered in the past.\n*/\nconst didFiberRender = (fiber) => {\n\tconst nextProps = fiber.memoizedProps;\n\tconst prevProps = fiber.alternate?.memoizedProps || {};\n\tconst flags = fiber.flags ?? fiber.effectTag ?? 0;\n\tswitch (fiber.tag) {\n\t\tcase ClassComponentTag:\n\t\tcase FunctionComponentTag:\n\t\tcase ContextConsumerTag:\n\t\tcase ForwardRefTag:\n\t\tcase MemoComponentTag:\n\t\tcase SimpleMemoComponentTag: return (flags & PerformedWork) === PerformedWork;\n\t\tdefault:\n\t\t\tif (!fiber.alternate) return true;\n\t\t\treturn prevProps !== nextProps || fiber.alternate.memoizedState !== fiber.memoizedState || fiber.alternate.ref !== fiber.ref;\n\t}\n};\n/**\n* Returns `true` if the {@link Fiber} has committed. Note that this does not mean the fiber has committed in the current commit, just that it has committed in the past.\n*/\nconst didFiberCommit = (fiber) => {\n\treturn Boolean((fiber.flags & (MutationMask | Cloned)) !== 0 || (fiber.subtreeFlags & (MutationMask | Cloned)) !== 0);\n};\n/**\n* Returns all host {@link Fiber}s that have committed and rendered.\n*/\nconst getMutatedHostFibers = (fiber) => {\n\tconst mutations = [];\n\tconst stack = [fiber];\n\twhile (stack.length) {\n\t\tconst node = stack.pop();\n\t\tif (!node) continue;\n\t\tif (isHostFiber(node) && didFiberCommit(node) && didFiberRender(node)) mutations.push(node);\n\t\tif (node.child) stack.push(node.child);\n\t\tif (node.sibling) stack.push(node.sibling);\n\t}\n\treturn mutations;\n};\n/**\n* Returns the stack of {@link Fiber}s from the current fiber to the root fiber.\n*\n* @example\n* ```ts\n* [fiber, fiber.return, fiber.return.return, ...]\n* ```\n*/\nconst getFiberStack = (fiber) => {\n\tconst stack = [];\n\tlet currentFiber = fiber;\n\twhile (currentFiber.return) {\n\t\tstack.push(currentFiber);\n\t\tcurrentFiber = currentFiber.return;\n\t}\n\treturn stack;\n};\n/**\n* Returns `true` if the {@link Fiber} should be filtered out during reconciliation.\n*/\nconst shouldFilterFiber = (fiber) => {\n\tswitch (fiber.tag) {\n\t\tcase DehydratedSuspenseComponentTag: return true;\n\t\tcase HostTextTag:\n\t\tcase FragmentTag:\n\t\tcase LegacyHiddenComponentTag:\n\t\tcase OffscreenComponentTag: return true;\n\t\tcase HostRootTag: return false;\n\t\tdefault: {\n\t\t\tconst symbolOrNumber = typeof fiber.type === \"object\" && fiber.type !== null ? fiber.type.$$typeof : fiber.type;\n\t\t\tconst typeSymbol = typeof symbolOrNumber === \"symbol\" ? symbolOrNumber.toString() : symbolOrNumber;\n\t\t\tswitch (typeSymbol) {\n\t\t\t\tcase CONCURRENT_MODE_NUMBER:\n\t\t\t\tcase CONCURRENT_MODE_SYMBOL_STRING:\n\t\t\t\tcase DEPRECATED_ASYNC_MODE_SYMBOL_STRING: return true;\n\t\t\t\tdefault: return false;\n\t\t\t}\n\t\t}\n\t}\n};\n/**\n* Returns the nearest host {@link Fiber} to the current {@link Fiber}.\n*/\nconst getNearestHostFiber = (fiber, ascending = false) => {\n\tlet hostFiber = traverseFiber(fiber, isHostFiber, ascending);\n\tif (!hostFiber) hostFiber = traverseFiber(fiber, isHostFiber, !ascending);\n\treturn hostFiber;\n};\n/**\n* Returns all host {@link Fiber}s in the tree that are associated with the current {@link Fiber}.\n*/\nconst getNearestHostFibers = (fiber) => {\n\tconst hostFibers = [];\n\tconst stack = [];\n\tif (isHostFiber(fiber)) hostFibers.push(fiber);\n\telse if (fiber.child) stack.push(fiber.child);\n\twhile (stack.length) {\n\t\tconst currentNode = stack.pop();\n\t\tif (!currentNode) break;\n\t\tif (isHostFiber(currentNode)) hostFibers.push(currentNode);\n\t\telse if (currentNode.child) stack.push(currentNode.child);\n\t\tif (currentNode.sibling) stack.push(currentNode.sibling);\n\t}\n\treturn hostFibers;\n};\nfunction traverseFiber(fiber, selector, ascending = false) {\n\tconst isAsync = fiber && selector(fiber) instanceof Promise;\n\tif (isAsync) return traverseFiberAsync(fiber, selector, ascending);\n\treturn traverseFiberSync(fiber, selector, ascending);\n}\nconst traverseFiberSync = (fiber, selector, ascending = false) => {\n\tif (!fiber) return null;\n\tif (selector(fiber) === true) return fiber;\n\tlet child = ascending ? fiber.return : fiber.child;\n\twhile (child) {\n\t\tconst match = traverseFiberSync(child, selector, ascending);\n\t\tif (match) return match;\n\t\tchild = ascending ? null : child.sibling;\n\t}\n\treturn null;\n};\nconst traverseFiberAsync = async (fiber, selector, ascending = false) => {\n\tif (!fiber) return null;\n\tif (await selector(fiber) === true) return fiber;\n\tlet child = ascending ? fiber.return : fiber.child;\n\twhile (child) {\n\t\tconst match = await traverseFiberAsync(child, selector, ascending);\n\t\tif (match) return match;\n\t\tchild = ascending ? null : child.sibling;\n\t}\n\treturn null;\n};\n/**\n* Returns the timings of the {@link Fiber}.\n*\n* @example\n* ```ts\n* const { selfTime, totalTime } = getTimings(fiber);\n* console.log(selfTime, totalTime);\n* ```\n*/\nconst getTimings = (fiber) => {\n\tconst totalTime = fiber?.actualDuration ?? 0;\n\tlet selfTime = totalTime;\n\tlet child = fiber?.child ?? null;\n\twhile (totalTime > 0 && child != null) {\n\t\tselfTime -= child.actualDuration ?? 0;\n\t\tchild = child.sibling;\n\t}\n\treturn {\n\t\tselfTime,\n\t\ttotalTime\n\t};\n};\n/**\n* Returns `true` if the {@link Fiber} uses React Compiler's memo cache.\n*/\nconst hasMemoCache = (fiber) => {\n\treturn Boolean(fiber.updateQueue?.memoCache);\n};\n/**\n* Returns the type (e.g. component definition) of the {@link Fiber}\n*/\nconst getType = (type) => {\n\tconst currentType = type;\n\tif (typeof currentType === \"function\") return currentType;\n\tif (typeof currentType === \"object\" && currentType) return getType(currentType.type || currentType.render);\n\treturn null;\n};\n/**\n* Returns the display name of the {@link Fiber} type.\n*/\nconst getDisplayName = (type) => {\n\tconst currentType = type;\n\tif (typeof currentType === \"string\") return currentType;\n\tif (typeof currentType !== \"function\" && !(typeof currentType === \"object\" && currentType)) return null;\n\tconst name = currentType.displayName || currentType.name || null;\n\tif (name) return name;\n\tconst unwrappedType = getType(currentType);\n\tif (!unwrappedType) return null;\n\treturn unwrappedType.displayName || unwrappedType.name || null;\n};\n/**\n* Returns the build type of the React renderer.\n*/\nconst detectReactBuildType = (renderer) => {\n\ttry {\n\t\tif (typeof renderer.version === \"string\" && renderer.bundleType > 0) return \"development\";\n\t} catch {}\n\treturn \"production\";\n};\n/**\n* Returns `true` if bippy's instrumentation is active.\n*/\nconst isInstrumentationActive = () => {\n\tconst rdtHook = getRDTHook();\n\treturn Boolean(rdtHook._instrumentationIsActive) || isRealReactDevtools() || isReactRefresh();\n};\n/**\n* Returns the latest fiber (since it may be double-buffered).\n*/\nconst getLatestFiber = (fiber) => {\n\tconst alternate = fiber.alternate;\n\tif (!alternate) return fiber;\n\tif (alternate.actualStartTime && fiber.actualStartTime) return alternate.actualStartTime > fiber.actualStartTime ? alternate : fiber;\n\tfor (const root of _fiberRoots) {\n\t\tconst latestFiber = traverseFiber(root.current, (innerFiber) => {\n\t\t\tif (innerFiber === fiber) return true;\n\t\t});\n\t\tif (latestFiber) return latestFiber;\n\t}\n\treturn fiber;\n};\nlet fiberId = 0;\nconst fiberIdMap = new WeakMap();\nconst setFiberId = (fiber, id = fiberId++) => {\n\tfiberIdMap.set(fiber, id);\n};\nconst getFiberId = (fiber) => {\n\tlet id = fiberIdMap.get(fiber);\n\tif (!id && fiber.alternate) id = fiberIdMap.get(fiber.alternate);\n\tif (!id) {\n\t\tid = fiberId++;\n\t\tsetFiberId(fiber, id);\n\t}\n\treturn id;\n};\nconst mountFiberRecursively = (onRender, firstChild, traverseSiblings) => {\n\tlet fiber = firstChild;\n\twhile (fiber != null) {\n\t\tif (!fiberIdMap.has(fiber)) getFiberId(fiber);\n\t\tconst shouldIncludeInTree = !shouldFilterFiber(fiber);\n\t\tif (shouldIncludeInTree && didFiberRender(fiber)) onRender(fiber, \"mount\");\n\t\tif (fiber.tag === SuspenseComponentTag) {\n\t\t\tconst isTimedOut = fiber.memoizedState !== null;\n\t\t\tif (isTimedOut) {\n\t\t\t\tconst primaryChildFragment = fiber.child;\n\t\t\t\tconst fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;\n\t\t\t\tif (fallbackChildFragment) {\n\t\t\t\t\tconst fallbackChild = fallbackChildFragment.child;\n\t\t\t\t\tif (fallbackChild !== null) mountFiberRecursively(onRender, fallbackChild, false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet primaryChild = null;\n\t\t\t\tconst areSuspenseChildrenConditionallyWrapped = OffscreenComponentTag === -1;\n\t\t\t\tif (areSuspenseChildrenConditionallyWrapped) primaryChild = fiber.child;\n\t\t\t\telse if (fiber.child !== null) primaryChild = fiber.child.child;\n\t\t\t\tif (primaryChild !== null) mountFiberRecursively(onRender, primaryChild, false);\n\t\t\t}\n\t\t} else if (fiber.child != null) mountFiberRecursively(onRender, fiber.child, true);\n\t\tfiber = traverseSiblings ? fiber.sibling : null;\n\t}\n};\nconst updateFiberRecursively = (onRender, nextFiber, prevFiber, parentFiber) => {\n\tif (!fiberIdMap.has(nextFiber)) getFiberId(nextFiber);\n\tif (!prevFiber) return;\n\tif (!fiberIdMap.has(prevFiber)) getFiberId(prevFiber);\n\tconst isSuspense = nextFiber.tag === SuspenseComponentTag;\n\tconst shouldIncludeInTree = !shouldFilterFiber(nextFiber);\n\tif (shouldIncludeInTree && didFiberRender(nextFiber)) onRender(nextFiber, \"update\");\n\tconst prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;\n\tconst nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null;\n\tif (prevDidTimeout && nextDidTimeOut) {\n\t\tconst nextFallbackChildSet = nextFiber.child?.sibling ?? null;\n\t\tconst prevFallbackChildSet = prevFiber.child?.sibling ?? null;\n\t\tif (nextFallbackChildSet !== null && prevFallbackChildSet !== null) updateFiberRecursively(onRender, nextFallbackChildSet, prevFallbackChildSet, nextFiber);\n\t} else if (prevDidTimeout && !nextDidTimeOut) {\n\t\tconst nextPrimaryChildSet = nextFiber.child;\n\t\tif (nextPrimaryChildSet !== null) mountFiberRecursively(onRender, nextPrimaryChildSet, true);\n\t} else if (!prevDidTimeout && nextDidTimeOut) {\n\t\tunmountFiberChildrenRecursively(onRender, prevFiber);\n\t\tconst nextFallbackChildSet = nextFiber.child?.sibling ?? null;\n\t\tif (nextFallbackChildSet !== null) mountFiberRecursively(onRender, nextFallbackChildSet, true);\n\t} else if (nextFiber.child !== prevFiber.child) {\n\t\tlet nextChild = nextFiber.child;\n\t\twhile (nextChild) {\n\t\t\tif (nextChild.alternate) {\n\t\t\t\tconst prevChild = nextChild.alternate;\n\t\t\t\tupdateFiberRecursively(onRender, nextChild, prevChild, shouldIncludeInTree ? nextFiber : parentFiber);\n\t\t\t} else mountFiberRecursively(onRender, nextChild, false);\n\t\t\tnextChild = nextChild.sibling;\n\t\t}\n\t}\n};\nconst unmountFiber = (onRender, fiber) => {\n\tconst isRoot = fiber.tag === HostRootTag;\n\tif (isRoot || !shouldFilterFiber(fiber)) onRender(fiber, \"unmount\");\n};\nconst unmountFiberChildrenRecursively = (onRender, fiber) => {\n\tconst isTimedOutSuspense = fiber.tag === SuspenseComponentTag && fiber.memoizedState !== null;\n\tlet child = fiber.child;\n\tif (isTimedOutSuspense) {\n\t\tconst primaryChildFragment = fiber.child;\n\t\tconst fallbackChildFragment = primaryChildFragment?.sibling ?? null;\n\t\tchild = fallbackChildFragment?.child ?? null;\n\t}\n\twhile (child !== null) {\n\t\tif (child.return !== null) {\n\t\t\tunmountFiber(onRender, child);\n\t\t\tunmountFiberChildrenRecursively(onRender, child);\n\t\t}\n\t\tchild = child.sibling;\n\t}\n};\nlet commitId = 0;\nconst rootInstanceMap = new WeakMap();\n/**\n* Creates a fiber visitor function. Must pass a fiber root and a render handler.\n* @example\n* traverseRenderedFibers(root, (fiber, phase) => {\n*   console.log(phase)\n* })\n*/\nconst traverseRenderedFibers = (root, onRender) => {\n\tconst fiber = \"current\" in root ? root.current : root;\n\tlet rootInstance = rootInstanceMap.get(root);\n\tif (!rootInstance) {\n\t\trootInstance = {\n\t\t\tprevFiber: null,\n\t\t\tid: commitId++\n\t\t};\n\t\trootInstanceMap.set(root, rootInstance);\n\t}\n\tconst { prevFiber } = rootInstance;\n\tif (!fiber) unmountFiber(onRender, fiber);\n\telse if (prevFiber !== null) {\n\t\tconst wasMounted = prevFiber && prevFiber.memoizedState != null && prevFiber.memoizedState.element != null && prevFiber.memoizedState.isDehydrated !== true;\n\t\tconst isMounted = fiber.memoizedState != null && fiber.memoizedState.element != null && fiber.memoizedState.isDehydrated !== true;\n\t\tif (!wasMounted && isMounted) mountFiberRecursively(onRender, fiber, false);\n\t\telse if (wasMounted && isMounted) updateFiberRecursively(onRender, fiber, fiber.alternate, null);\n\t\telse if (wasMounted && !isMounted) unmountFiber(onRender, fiber);\n\t} else mountFiberRecursively(onRender, fiber, true);\n\trootInstance.prevFiber = fiber;\n};\n/**\n* @deprecated use `traverseRenderedFibers` instead\n*/\nconst createFiberVisitor = ({ onRender }) => {\n\treturn (_rendererID, root, _state) => {\n\t\ttraverseRenderedFibers(root, onRender);\n\t};\n};\nlet _overrideProps = null;\nlet _overrideHookState = null;\nlet _overrideContext = null;\nconst injectOverrideMethods = () => {\n\tif (!hasRDTHook()) return null;\n\tconst rdtHook = getRDTHook();\n\tif (!rdtHook?.renderers) return null;\n\tif (_overrideProps || _overrideHookState || _overrideContext) return {\n\t\toverrideProps: _overrideProps,\n\t\toverrideHookState: _overrideHookState,\n\t\toverrideContext: _overrideContext\n\t};\n\tfor (const [_, renderer] of Array.from(rdtHook.renderers)) try {\n\t\tif (_overrideHookState) {\n\t\t\tconst prevOverrideHookState = _overrideHookState;\n\t\t\t_overrideHookState = (fiber, id, path, value) => {\n\t\t\t\tlet current = fiber.memoizedState;\n\t\t\t\tfor (let i = 0; i < Number(id); i++) {\n\t\t\t\t\tif (!current?.next) break;\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t}\n\t\t\t\tif (current?.queue) {\n\t\t\t\t\tconst queue = current.queue;\n\t\t\t\t\tif (isPOJO(queue) && \"dispatch\" in queue) {\n\t\t\t\t\t\tconst dispatch = queue.dispatch;\n\t\t\t\t\t\tdispatch(value);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprevOverrideHookState(fiber, id, path, value);\n\t\t\t\trenderer.overrideHookState?.(fiber, id, path, value);\n\t\t\t};\n\t\t} else if (renderer.overrideHookState) _overrideHookState = renderer.overrideHookState;\n\t\tif (_overrideProps) {\n\t\t\tconst prevOverrideProps = _overrideProps;\n\t\t\t_overrideProps = (fiber, path, value) => {\n\t\t\t\tprevOverrideProps(fiber, path, value);\n\t\t\t\trenderer.overrideProps?.(fiber, path, value);\n\t\t\t};\n\t\t} else if (renderer.overrideProps) _overrideProps = renderer.overrideProps;\n\t\t_overrideContext = (fiber, contextType, path, value) => {\n\t\t\tlet current = fiber;\n\t\t\twhile (current) {\n\t\t\t\tconst type = current.type;\n\t\t\t\tif (type === contextType || type?.Provider === contextType) {\n\t\t\t\t\tif (_overrideProps) {\n\t\t\t\t\t\t_overrideProps(current, [\"value\", ...path], value);\n\t\t\t\t\t\tif (current.alternate) _overrideProps(current.alternate, [\"value\", ...path], value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcurrent = current.return;\n\t\t\t}\n\t\t};\n\t} catch {}\n};\nconst isPOJO = (maybePOJO) => {\n\treturn Object.prototype.toString.call(maybePOJO) === \"[object Object]\" && (Object.getPrototypeOf(maybePOJO) === Object.prototype || Object.getPrototypeOf(maybePOJO) === null);\n};\nconst buildPathsFromValue = (maybePOJO, basePath = []) => {\n\tif (!isPOJO(maybePOJO)) return [{\n\t\tpath: basePath,\n\t\tvalue: maybePOJO\n\t}];\n\tconst paths = [];\n\tfor (const key in maybePOJO) {\n\t\tconst value = maybePOJO[key];\n\t\tconst path = basePath.concat(key);\n\t\tif (isPOJO(value)) paths.push(...buildPathsFromValue(value, path));\n\t\telse paths.push({\n\t\t\tpath,\n\t\t\tvalue\n\t\t});\n\t}\n\treturn paths;\n};\nconst overrideProps = (fiber, partialValue) => {\n\tinjectOverrideMethods();\n\tconst paths = buildPathsFromValue(partialValue);\n\tfor (const { path, value } of paths) try {\n\t\t_overrideProps?.(fiber, path, value);\n\t} catch {}\n};\nconst overrideHookState = (fiber, id, partialValue) => {\n\tinjectOverrideMethods();\n\tconst hookId = String(id);\n\tif (isPOJO(partialValue)) {\n\t\tconst paths = buildPathsFromValue(partialValue);\n\t\tfor (const { path, value } of paths) try {\n\t\t\t_overrideHookState?.(fiber, hookId, path, value);\n\t\t} catch {}\n\t} else try {\n\t\t_overrideHookState?.(fiber, hookId, [], partialValue);\n\t} catch {}\n};\nconst overrideContext = (fiber, contextType, partialValue) => {\n\tinjectOverrideMethods();\n\tif (isPOJO(partialValue)) {\n\t\tconst paths = buildPathsFromValue(partialValue);\n\t\tfor (const { path, value } of paths) try {\n\t\t\t_overrideContext?.(fiber, contextType, path, value);\n\t\t} catch {}\n\t} else try {\n\t\t_overrideContext?.(fiber, contextType, [], partialValue);\n\t} catch {}\n};\n/**\n* Instruments the DevTools hook.\n* @example\n* const hook = instrument({\n*   onActive() {\n*     console.log('initialized');\n*   },\n*   onCommitFiberRoot(rendererID, root) {\n*     console.log('fiberRoot', root.current)\n*   },\n* });\n*/\nconst instrument = (options) => {\n\treturn getRDTHook(() => {\n\t\tconst rdtHook = getRDTHook();\n\t\toptions.onActive?.();\n\t\trdtHook._instrumentationSource = options.name ?? BIPPY_INSTRUMENTATION_STRING;\n\t\tconst prevOnCommitFiberRoot = rdtHook.onCommitFiberRoot;\n\t\tif (options.onCommitFiberRoot) rdtHook.onCommitFiberRoot = (rendererID, root, priority) => {\n\t\t\tif (prevOnCommitFiberRoot) prevOnCommitFiberRoot(rendererID, root, priority);\n\t\t\toptions.onCommitFiberRoot?.(rendererID, root, priority);\n\t\t};\n\t\tconst prevOnCommitFiberUnmount = rdtHook.onCommitFiberUnmount;\n\t\tif (options.onCommitFiberUnmount) rdtHook.onCommitFiberUnmount = (rendererID, root) => {\n\t\t\tif (prevOnCommitFiberUnmount) prevOnCommitFiberUnmount(rendererID, root);\n\t\t\toptions.onCommitFiberUnmount?.(rendererID, root);\n\t\t};\n\t\tconst prevOnPostCommitFiberRoot = rdtHook.onPostCommitFiberRoot;\n\t\tif (options.onPostCommitFiberRoot) rdtHook.onPostCommitFiberRoot = (rendererID, root) => {\n\t\t\tif (prevOnPostCommitFiberRoot) prevOnPostCommitFiberRoot(rendererID, root);\n\t\t\toptions.onPostCommitFiberRoot?.(rendererID, root);\n\t\t};\n\t});\n};\nconst getFiberFromHostInstance = (hostInstance) => {\n\tconst rdtHook = getRDTHook();\n\tfor (const renderer of rdtHook.renderers.values()) try {\n\t\tconst fiber = renderer.findFiberByHostInstance?.(hostInstance);\n\t\tif (fiber) return fiber;\n\t} catch {}\n\tif (typeof hostInstance === \"object\" && hostInstance != null) {\n\t\tif (\"_reactRootContainer\" in hostInstance) return hostInstance._reactRootContainer?._internalRoot?.current?.child;\n\t\tfor (const key in hostInstance) if (key.startsWith(\"__reactContainer$\") || key.startsWith(\"__reactInternalInstance$\") || key.startsWith(\"__reactFiber\")) return hostInstance[key] || null;\n\t}\n\treturn null;\n};\nconst INSTALL_ERROR = new Error();\nconst _fiberRoots = new Set();\nconst secure = (options, secureOptions = {}) => {\n\tconst onActive = options.onActive;\n\tconst isRDTHookInstalled = hasRDTHook();\n\tconst isUsingRealReactDevtools = isRealReactDevtools();\n\tconst isUsingReactRefresh = isReactRefresh();\n\tlet timeout;\n\tlet isDevelopment = !secureOptions.isProduction;\n\toptions.onActive = () => {\n\t\tclearTimeout(timeout);\n\t\tlet isSecure = true;\n\t\ttry {\n\t\t\tconst rdtHook = getRDTHook();\n\t\t\tfor (const renderer of rdtHook.renderers.values()) {\n\t\t\t\tconst [majorVersion] = renderer.version.split(\".\");\n\t\t\t\tif (Number(majorVersion) < (secureOptions.minReactMajorVersion ?? 17)) isSecure = false;\n\t\t\t\tconst buildType = detectReactBuildType(renderer);\n\t\t\t\tif (buildType === \"development\") isDevelopment = true;\n\t\t\t\telse if (!secureOptions.dangerouslyRunInProduction) isSecure = false;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tsecureOptions.onError?.(err);\n\t\t}\n\t\tif (!isSecure) {\n\t\t\toptions.onCommitFiberRoot = void 0;\n\t\t\toptions.onCommitFiberUnmount = void 0;\n\t\t\toptions.onPostCommitFiberRoot = void 0;\n\t\t\toptions.onActive = void 0;\n\t\t\treturn;\n\t\t}\n\t\tonActive?.();\n\t\ttry {\n\t\t\tconst onCommitFiberRoot$1 = options.onCommitFiberRoot;\n\t\t\tif (onCommitFiberRoot$1) options.onCommitFiberRoot = (rendererID, root, priority) => {\n\t\t\t\tif (!_fiberRoots.has(root)) _fiberRoots.add(root);\n\t\t\t\ttry {\n\t\t\t\t\tonCommitFiberRoot$1(rendererID, root, priority);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tsecureOptions.onError?.(err);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst onCommitFiberUnmount = options.onCommitFiberUnmount;\n\t\t\tif (onCommitFiberUnmount) options.onCommitFiberUnmount = (rendererID, root) => {\n\t\t\t\ttry {\n\t\t\t\t\tonCommitFiberUnmount(rendererID, root);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tsecureOptions.onError?.(err);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst onPostCommitFiberRoot = options.onPostCommitFiberRoot;\n\t\t\tif (onPostCommitFiberRoot) options.onPostCommitFiberRoot = (rendererID, root) => {\n\t\t\t\ttry {\n\t\t\t\t\tonPostCommitFiberRoot(rendererID, root);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tsecureOptions.onError?.(err);\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (err) {\n\t\t\tsecureOptions.onError?.(err);\n\t\t}\n\t};\n\tif (!isRDTHookInstalled && !isUsingRealReactDevtools && !isUsingReactRefresh) timeout = setTimeout(() => {\n\t\tif (isDevelopment) secureOptions.onError?.(INSTALL_ERROR);\n\t\tstop();\n\t}, secureOptions.installCheckTimeout ?? 100);\n\treturn options;\n};\n/**\n* a wrapper around the {@link instrument} function that sets the `onCommitFiberRoot` hook.\n*\n* @example\n* onCommitFiberRoot((root) => {\n*   console.log(root.current);\n* });\n*/\nconst onCommitFiberRoot = (handler) => {\n\treturn instrument(secure({ onCommitFiberRoot: (_, root) => {\n\t\thandler(root);\n\t} }));\n};\n\n//#endregion\n//#region src/index.ts\nsafelyInstallRDTHook();\n\n//#endregion\nexport { ActivityComponentTag, BIPPY_INSTRUMENTATION_STRING, CONCURRENT_MODE_NUMBER, CONCURRENT_MODE_SYMBOL_STRING, ClassComponentTag, ContextConsumerTag, DEPRECATED_ASYNC_MODE_SYMBOL_STRING, DehydratedSuspenseComponentTag, ELEMENT_TYPE_SYMBOL_STRING, ForwardRefTag, FragmentTag, FunctionComponentTag, HostComponentTag, HostHoistableTag, HostRootTag, HostSingletonTag, HostTextTag, INSTALL_ERROR, LazyComponentTag, LegacyHiddenComponentTag, MemoComponentTag, OffscreenComponentTag, SimpleMemoComponentTag, SuspenseComponentTag, SuspenseListComponentTag, TRANSITIONAL_ELEMENT_TYPE_SYMBOL_STRING, ViewTransitionComponentTag, _fiberRoots, _renderers, areFiberEqual, createFiberVisitor, detectReactBuildType, didFiberCommit, didFiberRender, fiberIdMap, getDisplayName, getFiberFromHostInstance, getFiberId, getFiberStack, getLatestFiber, getMutatedHostFibers, getNearestHostFiber, getNearestHostFibers, getRDTHook, getTimings, getType, hasMemoCache, hasRDTHook, injectOverrideMethods, installRDTHook, instrument, isClientEnvironment, isCompositeFiber, isHostFiber, isInstrumentationActive, isReactRefresh, isRealReactDevtools, isValidElement, isValidFiber, mountFiberRecursively, onCommitFiberRoot, overrideContext, overrideHookState, overrideProps, patchRDTHook, safelyInstallRDTHook, secure, setFiberId, shouldFilterFiber, traverseContexts, traverseFiber, traverseFiberAsync, traverseFiberSync, traverseProps, traverseRenderedFibers, traverseState, unmountFiber, unmountFiberChildrenRecursively, updateFiberRecursively, version };"],"names":["version","BIPPY_INSTRUMENTATION_STRING","objectDefineProperty","objectHasOwnProperty","NO_OP","checkDCE","fn","isRealReactDevtools","rdtHook","getRDTHook","isReactRefreshOverride","injectFnStr","isReactRefresh","onActiveListeners","_renderers","installRDTHook","onActive","renderers","i","renderer","nextID","listener","newHook","ourRenderers","id","patchRDTHook","originalWindowHasOwnProperty","hasRanHack","prevInject","hasRDTHook","isClientEnvironment","safelyInstallRDTHook","FunctionComponentTag","ClassComponentTag","HostRootTag","HostTextTag","FragmentTag","ContextConsumerTag","ForwardRefTag","SuspenseComponentTag","MemoComponentTag","SimpleMemoComponentTag","DehydratedSuspenseComponentTag","OffscreenComponentTag","LegacyHiddenComponentTag","CONCURRENT_MODE_NUMBER","CONCURRENT_MODE_SYMBOL_STRING","DEPRECATED_ASYNC_MODE_SYMBOL_STRING","PerformedWork","didFiberRender","fiber","nextProps","prevProps","flags","getFiberStack","stack","currentFiber","shouldFilterFiber","symbolOrNumber","getType","type","currentType","getDisplayName","name","unwrappedType","fiberId","fiberIdMap","setFiberId","getFiberId","mountFiberRecursively","onRender","firstChild","traverseSiblings","primaryChildFragment","fallbackChildFragment","fallbackChild","primaryChild","updateFiberRecursively","nextFiber","prevFiber","parentFiber","isSuspense","prevDidTimeout","nextDidTimeOut","nextFallbackChildSet","prevFallbackChildSet","nextPrimaryChildSet","unmountFiberChildrenRecursively","nextChild","prevChild","unmountFiber","isTimedOutSuspense","child","commitId","rootInstanceMap","traverseRenderedFibers","root","rootInstance","wasMounted","isMounted","instrument","options","prevOnCommitFiberRoot","rendererID","priority","prevOnCommitFiberUnmount","prevOnPostCommitFiberRoot"],"mappings":"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","x_google_ignoreList":[0]}