---
title: "Yarn: The Good Parts"
slug: "posts/drafts/c76a8169-e153-4981-b780-80fcf1b75f1a"
tags: ["yarn", "berry", "javascript"]
createdAt: 2025-08-06
image: /src/assets/pkcen3s6x5403jl6usey.jpeg
description: "TODO"
sidebar:
  order: 3
  hidden: true
pagefind: false
wip: true
---

import LinkToPost from "@components/LinkToPost.astro";

:::caution[Warning]
Still in draft
:::

## Introduction

A few years ago, `npm` was released, changing forever the JavaScript & Node.js environment. But `npm` was very slow in its first versions, so Facebook released another package manager: yarnpkg. It was promising a few interesting features compared to npm at the time:

- faster installs,
- nicer DX:
  - with automatic shortcuts like `yarn <cmd>` instead of `npm run <cmd>`,
  - support for workspaces,
- safer with a lockfile, ensuring that everyone would get the same versions after a `yarn install`
  With npm, if the version "^1.0.0" of a package was installed, you could do the install and get 1.1.0, and redo the install a week later and get 1.1.2 without any visible changes in your package.json

All of those lead to Yarn being the de-facto package manager for JavaScript projects.

Alas, this changed with the years for a few reasons:

- yarn went through a huge breaking change with its v2 codename "yarn berry",
- npm started to get faster and add missing features like workspaces & implementing lockfile,
- pnpm was released, building up on the last 2 package managers and being even faster.

The v2 migration is the biggest reason why people moved away from yarn: when released, v2.0.0 was not fully stable (specially with node_modules), and was forcing people to switch to [Plug'n'Play](https://yarnpkg.com/features/pnp) (a version without node_modules). But almost 0 package in the ecosystem was compatible with it.

The goal of this article is to mention that Yarn is still relevant in 2025+.

## Background

Hello, I'm Ayc0, a Frontend Engineer working for [Datadog](https://datadoghq.com/). To give a bit more context about Datadog, our frontend repository is **big**:

- about 12M lines of TypeScript code,
- more than 5k packages (using yarn workspace),
- about 2M CI jobs per month,
- for more than 5k PRs per for month.

At this scale, having a tool that ensures us safety, speed, and the ability to audit, act, and enforce patterns across the whole codebase is not a desire: it’s a requirement.

## Features

Let’s dive into a few of very good features that Yarn has. For each of those features, I’ll mention if they are unique to yarn, or if other package managers share similar features.

TODO: DO I WANNA DO THAT?

### Auto pin yarn version per repository

To enable yarn 2+, you need to set `yarn set version berry`, or `yarn set version 4.0.0`. This will do 3 things:

- Set in your `package.json` a field `"packageManage": "yarn@<version>"`,
- Create / Add to your `.yarnrc.yml` a few field `yarnPath: ".yarn/releases/yarn-<version>.cjs"`,
- Add a new file to your repository: `.yarn/releases/yarn-<version>.cjs`

This `.yarn/releases` folder should be tracked by Git (but not necessarily the rest of the .yarn folder, please follow [Yarn best practices around Git usage](https://yarnpkg.com/getting-started/qa#which-files-should-be-gitignored)).

Even if this can be a bit annoying as it has to be done for **each repository** using Yarn 2+, it is very nice to ensure that everyone in your repo is using the same version. No matter which global yarn version setup on anyone’s computer, this local version will be used.

This is mostly beneficiary in 3 use-cases:

- Sharing the same version between local and CI without having to update the CI config when updating yarn locally,
- For very big repositories with a lot of contributors (to update all of them at once without any manipulation on their end),
- For repositories with a lot of 1 time new contributors / open source repositories.

This can also be solved by tools like [Volta](https://volta.sh) can also allow you to setup a similar behavior, but it requires an external tool to be installed.
And `pnpm` for instance solves it by hard crashing if you aren’t using the exact same version as written in your package.json’s `packageManager` field. But it won’t auto update your users, nor work that nicely if you have different repositories using different versions of pnpm.

## ROUGH SKETCH

- [x] ~background~
- [x] auto pin mechanism
- [ ] speed
- [ ] v1 -> v3+ easy migration & node_modules
- [ ] directive & multiple packages
- [ ] `yarn up` & `yarn up -R`
- [ ] constraints (v4+)
- [ ] plugins
- [ ] patch
- [ ] yarn config
- [ ] peer deps no build
- [ ] workspace
- [ ] publish & publishConfig & workspace directive
