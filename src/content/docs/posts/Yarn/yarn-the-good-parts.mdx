---
title: "Yarn: The Good Parts"
slug: "posts/drafts/c76a8169-e153-4981-b780-80fcf1b75f1a"
tags: ["yarn"]
createdAt: 2025-08-06
image: /src/assets/pkcen3s6x5403jl6usey.jpeg
description: "TODO"
sidebar:
  order: 3
pagefind: false
wip: true
---

import LinkToPost from "@components/LinkToPost.astro";

:::caution[Warning]
Still in draft
:::

## Introduction

A few years ago, `npm` was released, changing forever the JavaScript & Node.js environment. But `npm` was very slow in its first versions, so Facebook released another package manager: yarnpkg. It was promising a few interesting features compared to npm at the time:

- faster installs,
- nicer DX:
  - with automatic shortcuts like `yarn <cmd>` instead of `npm run <cmd>`,
  - support for workspaces,
- safer with a lockfile, ensuring that everyone would get the same versions after a `yarn install`
  With npm, if the version "^1.0.0" of a package was installed, you could do the install and get 1.1.0, and redo the install a week later and get 1.1.2 without any visible changes in your package.json

All of those lead to Yarn being the de-facto package manager for JavaScript projects.

Alas, this changed with the years for a few reasons:

- yarn went through a huge breaking change with its v2 codename "yarn berry",
- npm started to get faster and add missing features like workspaces & implementing lockfile,
- pnpm was released, building up on the last 2 package managers and being even faster.

The v2 migration is the biggest reason why people moved away from yarn: when released, v2.0.0 was not fully stable (specially with node_modules), and was forcing people to switch to [Plug'n'Play](https://yarnpkg.com/features/pnp) (a version without node_modules). But almost 0 packages in the ecosystem were compatible with it.

The goal of this article is to mention that Yarn is still relevant in 2025+.

## Background

Hello, I'm Ayc0, a Frontend Engineer working for [Datadog](https://datadoghq.com/). To give a bit more context about Datadog, our frontend repository is **big**:

- about 12M lines of TypeScript code,
- more than 5k packages (using yarn workspace),
- about 2M CI jobs per month,
- for more than 5k PRs per month.

At this scale, having a tool that ensures us safety, speed, and the ability to audit, act, and enforce patterns across the whole codebase is not a desire: itâ€™s a requirement.

## Features

Letâ€™s dive into a few of the very good features that Yarn has. For each of those features, Iâ€™ll mention if they are unique to yarn, or if other package managers share similar features.

TODO: DO I WANNA DO THAT?

### Auto pin yarn version per repository

To enable yarn 2+, you need to set `yarn set version berry`, or `yarn set version 4.0.0`. This will do 3 things:

- Set in your `package.json` a field `"packageManager": "yarn@<version>"`,
- Create / Add to your `.yarnrc.yml` a few field `yarnPath: ".yarn/releases/yarn-<version>.cjs"`,
- Add a new file to your repository: `.yarn/releases/yarn-<version>.cjs`

This `.yarn/releases` folder should be tracked by Git (but not necessarily the rest of the .yarn folder, please follow [Yarn best practices around Git usage](https://yarnpkg.com/getting-started/qa#which-files-should-be-gitignored)).

Even if this can be a bit annoying as it has to be done for **each repository** using Yarn 2+, it is very nice to ensure that everyone in your repo is using the same version. No matter which global yarn version setup on anyoneâ€™s computer, this local version will be used.

This is mostly beneficiary in 3 use-cases:

- Sharing the same version between local and CI without having to update the CI config when updating yarn locally,
- For very big repositories with a lot of contributors (to update all of them at once without any manipulation on their end),
- For repositories with a lot of 1 time new contributors / open source repositories.

This can also be solved by tools like [Volta](https://volta.sh) can also allow you to set up a similar behavior, but it requires an external tool to be installed.
And `pnpm` for instance solves it by hard crashing if you arenâ€™t using the exact same version as written in your package.jsonâ€™s `packageManager` field. But it wonâ€™t auto update your users, nor work that nicely if you have different repositories using different versions of pnpm.

### Speed

For this section, Iâ€™ll use 2 metrics: benchmarks created by [pnpm](https://pnpm.io/benchmarks) and [yarn](https://yarnpkg.com/features/performances), and my personal experience.

To me, only 3 metrics matter (as they are related to operations done the most by devs):

- 1st time install (with no cache, no node_modules, but a lockfile already filed),
- adding/removing a package,
- running install with full cache

In all of those 3 categories, yarn has around the same speed as pnpm (which is considered the reference in term of performances), or sometimes even faster when using Plug'n'Play (as it doesnâ€™t have to write into the z
`node_modules/` folder).

And when running with PNP, you wonâ€™t even have to run `yarn install` that often as all packages will always be here.

### Automatic update from yarn 1

Letâ€™s tackle the elephant in the room: yarn 2. Updating from Yarn 1 to Yarn 2 was very rough when it was released. I wonâ€™t go in more details here, but Yarn 2 is **not** a finished product. But the Yarn team acknowledged its issues, and fixed them in Yarn 3. And they went even further with Yarn 4.

:::tip[You can quote me on that]
Yarn 3 is what Yarn 2 should have been.
And Yarn 4 is what people wanted Yarn 2 to be.
:::

If you have a project running Yarn 1, just run `yarn set version 3.7.0`. This will:

- add a new `.yarn/releases/yarn-3.7.0.cjs` file,
- add `"packageManager": "yarn@3.7.0"` in package.json,
- create a new `.yarnrc.yml` file with:

```yaml title=".yarnrc.yml"
yarnPath: .yarn/releases/yarn-3.7.0.cjs
```

And after running `yarn install`, itâ€™ll tell you:

```txt wrap
âž¤ YN0070: Migrating from Yarn 1; automatically enabling the compatibility node-modules linker ðŸ‘
```

:::note
In Yarn 4, itâ€™ll say instead a more generic error message, but the principle is the same:

```txt wrap
âž¤ YN0087: Migrated your project to the latest Yarn version ðŸš€
```

:::

And then modify your `.yarnrc.yml` into:

```yaml title=".yarnrc.yml"
nodeLinker: node-modules

yarnPath: .yarn/releases/yarn-3.7.0.cjs
```

By default, yarn berry uses PNP and not node_modules. But `nodeLinker: node-modules` will tell it to use node_modules/ again. This linker is fully stable, and makes Yarn fully compatible with the rest of the ecosystem. Iâ€™ve never seen any single project that wasn't working with it (even React-Native projects).

There are other options that will be deprecated between each Yarn major, and most of the time, Yarn 3+ will auto-fix most of them with this code: [YN0087](https://yarnpkg.com/advanced/error-codes#yn0087---migration_success).

## ROUGH SKETCH

- [x] ~background~
- [x] auto pin mechanism
- [x] speed
- [x] v1 -> v3+ easy migration & node_modules
- [ ] directive & multiple packages
- [ ] `yarn up` & `yarn up -R`
- [ ] constraints (v4+)
- [ ] plugins
- [ ] patch
- [ ] yarn config
- [ ] peer deps no build
- [ ] workspace
- [ ] publish & publishConfig & workspace directive
